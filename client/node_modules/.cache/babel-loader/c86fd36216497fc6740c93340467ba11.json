{"ast":null,"code":"import { CHANNEL_EVENTS, CONNECTION_STATE, DEFAULT_HEADERS, DEFAULT_TIMEOUT, SOCKET_STATES, TRANSPORTS, VSN, WS_CLOSE_NORMAL } from './lib/constants';\nimport Serializer from './lib/serializer';\nimport Timer from './lib/timer';\nimport { httpEndpointURL } from './lib/transformers';\nimport RealtimeChannel from './RealtimeChannel';\n\nconst noop = () => {};\n\nconst NATIVE_WEBSOCKET_AVAILABLE = typeof WebSocket !== 'undefined';\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`;\nexport default class RealtimeClient {\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n   */\n  constructor(endPoint, options) {\n    var _a;\n\n    this.accessTokenValue = null;\n    this.apiKey = null;\n    this.channels = [];\n    this.endPoint = '';\n    this.httpEndpoint = '';\n    this.headers = DEFAULT_HEADERS;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.heartbeatIntervalMs = 30000;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.ref = 0;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.accessToken = null;\n    /**\n     * Use either custom fetch, if provided, or default fetch to make HTTP requests\n     *\n     * @internal\n     */\n\n    this._resolveFetch = customFetch => {\n      let _fetch;\n\n      if (customFetch) {\n        _fetch = customFetch;\n      } else if (typeof fetch === 'undefined') {\n        _fetch = function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return import('@supabase/node-fetch').then(_ref => {\n            let {\n              default: fetch\n            } = _ref;\n            return fetch(...args);\n          });\n        };\n      } else {\n        _fetch = fetch;\n      }\n\n      return function () {\n        return _fetch(...arguments);\n      };\n    };\n\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    this.httpEndpoint = httpEndpointURL(endPoint);\n\n    if (options === null || options === void 0 ? void 0 : options.transport) {\n      this.transport = options.transport;\n    } else {\n      this.transport = null;\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    const accessTokenValue = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey;\n\n    if (accessTokenValue) {\n      this.accessTokenValue = accessTokenValue;\n      this.apiKey = accessTokenValue;\n    }\n\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : tries => {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer(async () => {\n      this.disconnect();\n      this.connect();\n    }, this.reconnectAfterMs);\n    this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n\n    if (options === null || options === void 0 ? void 0 : options.worker) {\n      if (typeof window !== 'undefined' && !window.Worker) {\n        throw new Error('Web Worker is not supported');\n      }\n\n      this.worker = (options === null || options === void 0 ? void 0 : options.worker) || false;\n      this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\n    }\n\n    this.accessToken = (options === null || options === void 0 ? void 0 : options.accessToken) || null;\n  }\n  /**\n   * Connects the socket, unless already connected.\n   */\n\n\n  connect() {\n    if (this.conn) {\n      return;\n    }\n\n    if (this.transport) {\n      this.conn = new this.transport(this.endpointURL(), undefined, {\n        headers: this.headers\n      });\n      return;\n    }\n\n    if (NATIVE_WEBSOCKET_AVAILABLE) {\n      this.conn = new WebSocket(this.endpointURL());\n      this.setupConnection();\n      return;\n    }\n\n    this.conn = new WSWebSocketDummy(this.endpointURL(), undefined, {\n      close: () => {\n        this.conn = null;\n      }\n    });\n    import('ws').then(_ref2 => {\n      let {\n        default: WS\n      } = _ref2;\n      this.conn = new WS(this.endpointURL(), undefined, {\n        headers: this.headers\n      });\n      this.setupConnection();\n    });\n  }\n  /**\n   * Returns the URL of the websocket.\n   * @returns string The URL of the websocket.\n   */\n\n\n  endpointURL() {\n    return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n      vsn: VSN\n    }));\n  }\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n\n\n  disconnect(code, reason) {\n    if (this.conn) {\n      this.conn.onclose = function () {}; // noop\n\n\n      if (code) {\n        this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n      } else {\n        this.conn.close();\n      }\n\n      this.conn = null; // remove open handles\n\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.reset();\n    }\n  }\n  /**\n   * Returns all created channels\n   */\n\n\n  getChannels() {\n    return this.channels;\n  }\n  /**\n   * Unsubscribes and removes a single channel\n   * @param channel A RealtimeChannel instance\n   */\n\n\n  async removeChannel(channel) {\n    const status = await channel.unsubscribe();\n\n    if (this.channels.length === 0) {\n      this.disconnect();\n    }\n\n    return status;\n  }\n  /**\n   * Unsubscribes and removes all channels\n   */\n\n\n  async removeAllChannels() {\n    const values_1 = await Promise.all(this.channels.map(channel => channel.unsubscribe()));\n    this.disconnect();\n    return values_1;\n  }\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overridden.\n   */\n\n\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  /**\n   * Returns the current state of the socket.\n   */\n\n\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting;\n\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open;\n\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing;\n\n      default:\n        return CONNECTION_STATE.Closed;\n    }\n  }\n  /**\n   * Returns `true` is the connection is open.\n   */\n\n\n  isConnected() {\n    return this.connectionState() === CONNECTION_STATE.Open;\n  }\n\n  channel(topic) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      config: {}\n    };\n    const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n    this.channels.push(chan);\n    return chan;\n  }\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n\n\n  push(data) {\n    const {\n      topic,\n      event,\n      payload,\n      ref\n    } = data;\n\n    const callback = () => {\n      this.encode(data, result => {\n        var _a;\n\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n      });\n    };\n\n    this.log('push', `${topic} ${event} (${ref})`, payload);\n\n    if (this.isConnected()) {\n      callback();\n    } else {\n      this.sendBuffer.push(callback);\n    }\n  }\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * If param is null it will use the `accessToken` callback function or the token set on the client.\n   *\n   * On callback used, it will set the value of the token internal to the client.\n   *\n   * @param token A JWT string to override the token set on the client.\n   */\n\n\n  async setAuth() {\n    let token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let tokenToSend = token || this.accessToken && (await this.accessToken()) || this.accessTokenValue;\n\n    if (tokenToSend) {\n      let parsed = null;\n\n      try {\n        parsed = JSON.parse(atob(tokenToSend.split('.')[1]));\n      } catch (_error) {}\n\n      if (parsed && parsed.exp) {\n        let now = Math.floor(Date.now() / 1000);\n        let valid = now - parsed.exp < 0;\n\n        if (!valid) {\n          this.log('auth', `InvalidJWTToken: Invalid value for JWT claim \"exp\" with value ${parsed.exp}`);\n          return Promise.reject(`InvalidJWTToken: Invalid value for JWT claim \"exp\" with value ${parsed.exp}`);\n        }\n      }\n\n      this.accessTokenValue = tokenToSend;\n      this.channels.forEach(channel => {\n        tokenToSend && channel.updateJoinPayload({\n          access_token: tokenToSend\n        });\n\n        if (channel.joinedOnce && channel._isJoined()) {\n          channel._push(CHANNEL_EVENTS.access_token, {\n            access_token: tokenToSend\n          });\n        }\n      });\n    }\n  }\n  /**\n   * Sends a heartbeat message if the socket is connected.\n   */\n\n\n  async sendHeartbeat() {\n    var _a;\n\n    if (!this.isConnected()) {\n      return;\n    }\n\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n      (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n      return;\n    }\n\n    this.pendingHeartbeatRef = this._makeRef();\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef\n    });\n    this.setAuth();\n  }\n  /**\n   * Flushes send buffer\n   */\n\n\n  flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach(callback => callback());\n      this.sendBuffer = [];\n    }\n  }\n  /**\n   * Return the next message ref, accounting for overflows\n   *\n   * @internal\n   */\n\n\n  _makeRef() {\n    let newRef = this.ref + 1;\n\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n\n    return this.ref.toString();\n  }\n  /**\n   * Unsubscribe from channels with the specified topic.\n   *\n   * @internal\n   */\n\n\n  _leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find(c => c.topic === topic && (c._isJoined() || c._isJoining()));\n\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`);\n      dupChannel.unsubscribe();\n    }\n  }\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   *\n   * @internal\n   */\n\n\n  _remove(channel) {\n    this.channels = this.channels.filter(c => c._joinRef() !== channel._joinRef());\n  }\n  /**\n   * Sets up connection handlers.\n   *\n   * @internal\n   */\n\n\n  setupConnection() {\n    if (this.conn) {\n      this.conn.binaryType = 'arraybuffer';\n\n      this.conn.onopen = () => this._onConnOpen();\n\n      this.conn.onerror = error => this._onConnError(error);\n\n      this.conn.onmessage = event => this._onConnMessage(event);\n\n      this.conn.onclose = event => this._onConnClose(event);\n    }\n  }\n  /** @internal */\n\n\n  _onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, msg => {\n      let {\n        topic,\n        event,\n        payload,\n        ref\n      } = msg;\n\n      if (ref && ref === this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n      }\n\n      this.log('receive', `${payload.status || ''} ${topic} ${event} ${ref && '(' + ref + ')' || ''}`, payload);\n      this.channels.filter(channel => channel._isMember(topic)).forEach(channel => channel._trigger(event, payload, ref));\n      this.stateChangeCallbacks.message.forEach(callback => callback(msg));\n    });\n  }\n  /** @internal */\n\n\n  async _onConnOpen() {\n    this.log('transport', `connected to ${this.endpointURL()}`);\n    this.flushSendBuffer();\n    this.reconnectTimer.reset();\n\n    if (!this.worker) {\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n    } else {\n      if (this.workerUrl) {\n        this.log('worker', `starting worker for from ${this.workerUrl}`);\n      } else {\n        this.log('worker', `starting default worker`);\n      }\n\n      const objectUrl = this._workerObjectUrl(this.workerUrl);\n\n      this.workerRef = new Worker(objectUrl);\n\n      this.workerRef.onerror = error => {\n        this.log('worker', 'worker error', error.message);\n        this.workerRef.terminate();\n      };\n\n      this.workerRef.onmessage = event => {\n        if (event.data.event === 'keepAlive') {\n          this.sendHeartbeat();\n        }\n      };\n\n      this.workerRef.postMessage({\n        event: 'start',\n        interval: this.heartbeatIntervalMs\n      });\n    }\n\n    this.stateChangeCallbacks.open.forEach(callback => callback());\n  }\n  /** @internal */\n\n\n  _onConnClose(event) {\n    this.log('transport', 'close', event);\n\n    this._triggerChanError();\n\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.reconnectTimer.scheduleTimeout();\n    this.stateChangeCallbacks.close.forEach(callback => callback(event));\n  }\n  /** @internal */\n\n\n  _onConnError(error) {\n    this.log('transport', error.message);\n\n    this._triggerChanError();\n\n    this.stateChangeCallbacks.error.forEach(callback => callback(error));\n  }\n  /** @internal */\n\n\n  _triggerChanError() {\n    this.channels.forEach(channel => channel._trigger(CHANNEL_EVENTS.error));\n  }\n  /** @internal */\n\n\n  _appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n\n    const prefix = url.match(/\\?/) ? '&' : '?';\n    const query = new URLSearchParams(params);\n    return `${url}${prefix}${query}`;\n  }\n\n  _workerObjectUrl(url) {\n    let result_url;\n\n    if (url) {\n      result_url = url;\n    } else {\n      const blob = new Blob([WORKER_SCRIPT], {\n        type: 'application/javascript'\n      });\n      result_url = URL.createObjectURL(blob);\n    }\n\n    return result_url;\n  }\n\n}\n\nclass WSWebSocketDummy {\n  constructor(address, _protocols, options) {\n    this.binaryType = 'arraybuffer';\n\n    this.onclose = () => {};\n\n    this.onerror = () => {};\n\n    this.onmessage = () => {};\n\n    this.onopen = () => {};\n\n    this.readyState = SOCKET_STATES.connecting;\n\n    this.send = () => {};\n\n    this.url = null;\n    this.url = address;\n    this.close = options.close;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["CHANNEL_EVENTS","CONNECTION_STATE","DEFAULT_HEADERS","DEFAULT_TIMEOUT","SOCKET_STATES","TRANSPORTS","VSN","WS_CLOSE_NORMAL","Serializer","Timer","httpEndpointURL","RealtimeChannel","noop","NATIVE_WEBSOCKET_AVAILABLE","WebSocket","WORKER_SCRIPT","RealtimeClient","constructor","endPoint","options","undefined","open","close","error","message","customFetch","_fetch","fetch","args","then","default","websocket","httpEndpoint","transport","params","headers","Object","timeout","logger","heartbeatIntervalMs","accessTokenValue","_a","apikey","apiKey","reconnectAfterMs","tries","encode","payload","callback","JSON","stringify","decode","serializer","bind","reconnectTimer","disconnect","connect","_resolveFetch","worker","window","Worker","Error","workerUrl","accessToken","conn","endpointURL","setupConnection","WSWebSocketDummy","WS","_appendParams","assign","vsn","code","reason","onclose","heartbeatTimer","clearInterval","reset","getChannels","channels","removeChannel","channel","status","unsubscribe","length","removeAllChannels","values_1","Promise","all","map","log","kind","msg","data","connectionState","readyState","connecting","Connecting","Open","closing","Closing","Closed","isConnected","topic","config","chan","push","event","ref","result","send","sendBuffer","setAuth","token","tokenToSend","parsed","parse","atob","split","_error","exp","now","Math","floor","Date","valid","reject","forEach","updateJoinPayload","access_token","joinedOnce","_isJoined","_push","sendHeartbeat","pendingHeartbeatRef","_makeRef","flushSendBuffer","newRef","toString","_leaveOpenTopic","dupChannel","find","c","_isJoining","_remove","filter","_joinRef","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","_onConnMessage","_onConnClose","rawMessage","_isMember","_trigger","stateChangeCallbacks","setInterval","objectUrl","_workerObjectUrl","workerRef","terminate","postMessage","interval","_triggerChanError","scheduleTimeout","url","keys","prefix","match","query","URLSearchParams","result_url","blob","Blob","type","URL","createObjectURL","address","_protocols"],"sources":["/Users/grove/Desktop/repos/web102_unit7lab/client/node_modules/@supabase/realtime-js/src/RealtimeClient.ts"],"sourcesContent":["import type { WebSocket as WSWebSocket } from 'ws'\n\nimport {\n  CHANNEL_EVENTS,\n  CONNECTION_STATE,\n  DEFAULT_HEADERS,\n  DEFAULT_TIMEOUT,\n  SOCKET_STATES,\n  TRANSPORTS,\n  VSN,\n  WS_CLOSE_NORMAL,\n} from './lib/constants'\nimport Serializer from './lib/serializer'\nimport Timer from './lib/timer'\n\nimport { httpEndpointURL } from './lib/transformers'\nimport RealtimeChannel from './RealtimeChannel'\nimport type { RealtimeChannelOptions } from './RealtimeChannel'\n\ntype Fetch = typeof fetch\n\nexport type Channel = {\n  name: string\n  inserted_at: string\n  updated_at: string\n  id: number\n}\n\nexport type RealtimeClientOptions = {\n  transport?: WebSocketLikeConstructor\n  timeout?: number\n  heartbeatIntervalMs?: number\n  logger?: Function\n  encode?: Function\n  decode?: Function\n  reconnectAfterMs?: Function\n  headers?: { [key: string]: string }\n  params?: { [key: string]: any }\n  log_level?: 'info' | 'debug' | 'warn' | 'error'\n  fetch?: Fetch\n  worker?: boolean\n  workerUrl?: string\n  accessToken?: () => Promise<string | null>\n}\n\nexport type RealtimeMessage = {\n  topic: string\n  event: string\n  payload: any\n  ref: string\n  join_ref?: string\n}\n\nexport type RealtimeRemoveChannelResponse = 'ok' | 'timed out' | 'error'\n\nconst noop = () => {}\n\nexport interface WebSocketLikeConstructor {\n  new (\n    address: string | URL,\n    _ignored?: any,\n    options?: { headers: Object | undefined }\n  ): WebSocketLike\n}\n\nexport type WebSocketLike = WebSocket | WSWebSocket | WSWebSocketDummy\n\nexport interface WebSocketLikeError {\n  error: any\n  message: string\n  type: string\n}\n\nconst NATIVE_WEBSOCKET_AVAILABLE = typeof WebSocket !== 'undefined'\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`\nexport default class RealtimeClient {\n  accessTokenValue: string | null = null\n  apiKey: string | null = null\n  channels: RealtimeChannel[] = []\n  endPoint: string = ''\n  httpEndpoint: string = ''\n  headers?: { [key: string]: string } = DEFAULT_HEADERS\n  params?: { [key: string]: string } = {}\n  timeout: number = DEFAULT_TIMEOUT\n  transport: WebSocketLikeConstructor | null\n  heartbeatIntervalMs: number = 30000\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\n  pendingHeartbeatRef: string | null = null\n  ref: number = 0\n  reconnectTimer: Timer\n  logger: Function = noop\n  encode: Function\n  decode: Function\n  reconnectAfterMs: Function\n  conn: WebSocketLike | null = null\n  sendBuffer: Function[] = []\n  serializer: Serializer = new Serializer()\n  stateChangeCallbacks: {\n    open: Function[]\n    close: Function[]\n    error: Function[]\n    message: Function[]\n  } = {\n    open: [],\n    close: [],\n    error: [],\n    message: [],\n  }\n  fetch: Fetch\n  accessToken: (() => Promise<string | null>) | null = null\n  worker?: boolean\n  workerUrl?: string\n  workerRef?: Worker\n\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n   */\n  constructor(endPoint: string, options?: RealtimeClientOptions) {\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\n    this.httpEndpoint = httpEndpointURL(endPoint)\n    if (options?.transport) {\n      this.transport = options.transport\n    } else {\n      this.transport = null\n    }\n    if (options?.params) this.params = options.params\n    if (options?.headers) this.headers = { ...this.headers, ...options.headers }\n    if (options?.timeout) this.timeout = options.timeout\n    if (options?.logger) this.logger = options.logger\n    if (options?.heartbeatIntervalMs)\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs\n\n    const accessTokenValue = options?.params?.apikey\n    if (accessTokenValue) {\n      this.accessTokenValue = accessTokenValue\n      this.apiKey = accessTokenValue\n    }\n\n    this.reconnectAfterMs = options?.reconnectAfterMs\n      ? options.reconnectAfterMs\n      : (tries: number) => {\n          return [1000, 2000, 5000, 10000][tries - 1] || 10000\n        }\n    this.encode = options?.encode\n      ? options.encode\n      : (payload: JSON, callback: Function) => {\n          return callback(JSON.stringify(payload))\n        }\n    this.decode = options?.decode\n      ? options.decode\n      : this.serializer.decode.bind(this.serializer)\n    this.reconnectTimer = new Timer(async () => {\n      this.disconnect()\n      this.connect()\n    }, this.reconnectAfterMs)\n\n    this.fetch = this._resolveFetch(options?.fetch)\n    if (options?.worker) {\n      if (typeof window !== 'undefined' && !window.Worker) {\n        throw new Error('Web Worker is not supported')\n      }\n      this.worker = options?.worker || false\n      this.workerUrl = options?.workerUrl\n    }\n    this.accessToken = options?.accessToken || null\n  }\n\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect(): void {\n    if (this.conn) {\n      return\n    }\n\n    if (this.transport) {\n      this.conn = new this.transport(this.endpointURL(), undefined, {\n        headers: this.headers,\n      })\n      return\n    }\n\n    if (NATIVE_WEBSOCKET_AVAILABLE) {\n      this.conn = new WebSocket(this.endpointURL())\n      this.setupConnection()\n      return\n    }\n\n    this.conn = new WSWebSocketDummy(this.endpointURL(), undefined, {\n      close: () => {\n        this.conn = null\n      },\n    })\n\n    import('ws').then(({ default: WS }) => {\n      this.conn = new WS(this.endpointURL(), undefined, {\n        headers: this.headers,\n      })\n      this.setupConnection()\n    })\n  }\n\n  /**\n   * Returns the URL of the websocket.\n   * @returns string The URL of the websocket.\n   */\n  endpointURL(): string {\n    return this._appendParams(\n      this.endPoint,\n      Object.assign({}, this.params, { vsn: VSN })\n    )\n  }\n\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(code?: number, reason?: string): void {\n    if (this.conn) {\n      this.conn.onclose = function () {} // noop\n      if (code) {\n        this.conn.close(code, reason ?? '')\n      } else {\n        this.conn.close()\n      }\n      this.conn = null\n      // remove open handles\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n      this.reconnectTimer.reset()\n    }\n  }\n\n  /**\n   * Returns all created channels\n   */\n  getChannels(): RealtimeChannel[] {\n    return this.channels\n  }\n\n  /**\n   * Unsubscribes and removes a single channel\n   * @param channel A RealtimeChannel instance\n   */\n  async removeChannel(\n    channel: RealtimeChannel\n  ): Promise<RealtimeRemoveChannelResponse> {\n    const status = await channel.unsubscribe()\n    if (this.channels.length === 0) {\n      this.disconnect()\n    }\n    return status\n  }\n\n  /**\n   * Unsubscribes and removes all channels\n   */\n  async removeAllChannels(): Promise<RealtimeRemoveChannelResponse[]> {\n    const values_1 = await Promise.all(\n      this.channels.map((channel) => channel.unsubscribe())\n    )\n    this.disconnect()\n    return values_1\n  }\n\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overridden.\n   */\n  log(kind: string, msg: string, data?: any) {\n    this.logger(kind, msg, data)\n  }\n\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState(): CONNECTION_STATE {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing\n      default:\n        return CONNECTION_STATE.Closed\n    }\n  }\n\n  /**\n   * Returns `true` is the connection is open.\n   */\n  isConnected(): boolean {\n    return this.connectionState() === CONNECTION_STATE.Open\n  }\n\n  channel(\n    topic: string,\n    params: RealtimeChannelOptions = { config: {} }\n  ): RealtimeChannel {\n    const chan = new RealtimeChannel(`realtime:${topic}`, params, this)\n    this.channels.push(chan)\n    return chan\n  }\n\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data: RealtimeMessage): void {\n    const { topic, event, payload, ref } = data\n    const callback = () => {\n      this.encode(data, (result: any) => {\n        this.conn?.send(result)\n      })\n    }\n    this.log('push', `${topic} ${event} (${ref})`, payload)\n    if (this.isConnected()) {\n      callback()\n    } else {\n      this.sendBuffer.push(callback)\n    }\n  }\n\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * If param is null it will use the `accessToken` callback function or the token set on the client.\n   *\n   * On callback used, it will set the value of the token internal to the client.\n   *\n   * @param token A JWT string to override the token set on the client.\n   */\n  async setAuth(token: string | null = null): Promise<void> {\n    let tokenToSend =\n      token ||\n      (this.accessToken && (await this.accessToken())) ||\n      this.accessTokenValue\n\n    if (tokenToSend) {\n      let parsed = null\n      try {\n        parsed = JSON.parse(atob(tokenToSend.split('.')[1]))\n      } catch (_error) {}\n      if (parsed && parsed.exp) {\n        let now = Math.floor(Date.now() / 1000)\n        let valid = now - parsed.exp < 0\n        if (!valid) {\n          this.log(\n            'auth',\n            `InvalidJWTToken: Invalid value for JWT claim \"exp\" with value ${parsed.exp}`\n          )\n          return Promise.reject(\n            `InvalidJWTToken: Invalid value for JWT claim \"exp\" with value ${parsed.exp}`\n          )\n        }\n      }\n\n      this.accessTokenValue = tokenToSend\n      this.channels.forEach((channel) => {\n        tokenToSend && channel.updateJoinPayload({ access_token: tokenToSend })\n\n        if (channel.joinedOnce && channel._isJoined()) {\n          channel._push(CHANNEL_EVENTS.access_token, {\n            access_token: tokenToSend,\n          })\n        }\n      })\n    }\n  }\n  /**\n   * Sends a heartbeat message if the socket is connected.\n   */\n  async sendHeartbeat() {\n    if (!this.isConnected()) {\n      return\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null\n      this.log(\n        'transport',\n        'heartbeat timeout. Attempting to re-establish connection'\n      )\n      this.conn?.close(WS_CLOSE_NORMAL, 'hearbeat timeout')\n      return\n    }\n    this.pendingHeartbeatRef = this._makeRef()\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef,\n    })\n    this.setAuth()\n  }\n\n  /**\n   * Flushes send buffer\n   */\n  flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback())\n      this.sendBuffer = []\n    }\n  }\n\n  /**\n   * Use either custom fetch, if provided, or default fetch to make HTTP requests\n   *\n   * @internal\n   */\n  _resolveFetch = (customFetch?: Fetch): Fetch => {\n    let _fetch: Fetch\n    if (customFetch) {\n      _fetch = customFetch\n    } else if (typeof fetch === 'undefined') {\n      _fetch = (...args) =>\n        import('@supabase/node-fetch' as any).then(({ default: fetch }) =>\n          fetch(...args)\n        )\n    } else {\n      _fetch = fetch\n    }\n    return (...args) => _fetch(...args)\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   *\n   * @internal\n   */\n  _makeRef(): string {\n    let newRef = this.ref + 1\n    if (newRef === this.ref) {\n      this.ref = 0\n    } else {\n      this.ref = newRef\n    }\n\n    return this.ref.toString()\n  }\n\n  /**\n   * Unsubscribe from channels with the specified topic.\n   *\n   * @internal\n   */\n  _leaveOpenTopic(topic: string): void {\n    let dupChannel = this.channels.find(\n      (c) => c.topic === topic && (c._isJoined() || c._isJoining())\n    )\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`)\n      dupChannel.unsubscribe()\n    }\n  }\n\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   *\n   * @internal\n   */\n  _remove(channel: RealtimeChannel) {\n    this.channels = this.channels.filter(\n      (c: RealtimeChannel) => c._joinRef() !== channel._joinRef()\n    )\n  }\n\n  /**\n   * Sets up connection handlers.\n   *\n   * @internal\n   */\n  private setupConnection(): void {\n    if (this.conn) {\n      this.conn.binaryType = 'arraybuffer'\n      this.conn.onopen = () => this._onConnOpen()\n      this.conn.onerror = (error: WebSocketLikeError) =>\n        this._onConnError(error as WebSocketLikeError)\n      this.conn.onmessage = (event: any) => this._onConnMessage(event)\n      this.conn.onclose = (event: any) => this._onConnClose(event)\n    }\n  }\n\n  /** @internal */\n  private _onConnMessage(rawMessage: { data: any }) {\n    this.decode(rawMessage.data, (msg: RealtimeMessage) => {\n      let { topic, event, payload, ref } = msg\n\n      if (ref && ref === this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null\n      }\n\n      this.log(\n        'receive',\n        `${payload.status || ''} ${topic} ${event} ${\n          (ref && '(' + ref + ')') || ''\n        }`,\n        payload\n      )\n      this.channels\n        .filter((channel: RealtimeChannel) => channel._isMember(topic))\n        .forEach((channel: RealtimeChannel) =>\n          channel._trigger(event, payload, ref)\n        )\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg))\n    })\n  }\n\n  /** @internal */\n  private async _onConnOpen() {\n    this.log('transport', `connected to ${this.endpointURL()}`)\n    this.flushSendBuffer()\n    this.reconnectTimer.reset()\n    if (!this.worker) {\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n      this.heartbeatTimer = setInterval(\n        () => this.sendHeartbeat(),\n        this.heartbeatIntervalMs\n      )\n    } else {\n      if (this.workerUrl) {\n        this.log('worker', `starting worker for from ${this.workerUrl}`)\n      } else {\n        this.log('worker', `starting default worker`)\n      }\n\n      const objectUrl = this._workerObjectUrl(this.workerUrl!)\n      this.workerRef = new Worker(objectUrl)\n      this.workerRef.onerror = (error) => {\n        this.log('worker', 'worker error', error.message)\n        this.workerRef!.terminate()\n      }\n      this.workerRef.onmessage = (event) => {\n        if (event.data.event === 'keepAlive') {\n          this.sendHeartbeat()\n        }\n      }\n      this.workerRef.postMessage({\n        event: 'start',\n        interval: this.heartbeatIntervalMs,\n      })\n    }\n\n    this.stateChangeCallbacks.open.forEach((callback) => callback())!\n  }\n\n  /** @internal */\n\n  private _onConnClose(event: any) {\n    this.log('transport', 'close', event)\n    this._triggerChanError()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.reconnectTimer.scheduleTimeout()\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event))\n  }\n\n  /** @internal */\n  private _onConnError(error: WebSocketLikeError) {\n    this.log('transport', error.message)\n    this._triggerChanError()\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error))\n  }\n\n  /** @internal */\n  private _triggerChanError() {\n    this.channels.forEach((channel: RealtimeChannel) =>\n      channel._trigger(CHANNEL_EVENTS.error)\n    )\n  }\n\n  /** @internal */\n  private _appendParams(\n    url: string,\n    params: { [key: string]: string }\n  ): string {\n    if (Object.keys(params).length === 0) {\n      return url\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?'\n    const query = new URLSearchParams(params)\n\n    return `${url}${prefix}${query}`\n  }\n\n  private _workerObjectUrl(url: string | undefined): string {\n    let result_url: string\n    if (url) {\n      result_url = url\n    } else {\n      const blob = new Blob([WORKER_SCRIPT], { type: 'application/javascript' })\n      result_url = URL.createObjectURL(blob)\n    }\n    return result_url\n  }\n}\n\nclass WSWebSocketDummy {\n  binaryType: string = 'arraybuffer'\n  close: Function\n  onclose: Function = () => {}\n  onerror: Function = () => {}\n  onmessage: Function = () => {}\n  onopen: Function = () => {}\n  readyState: number = SOCKET_STATES.connecting\n  send: Function = () => {}\n  url: string | URL | null = null\n\n  constructor(\n    address: string,\n    _protocols: undefined,\n    options: { close: Function }\n  ) {\n    this.url = address\n    this.close = options.close\n  }\n}\n"]},"metadata":{},"sourceType":"module"}