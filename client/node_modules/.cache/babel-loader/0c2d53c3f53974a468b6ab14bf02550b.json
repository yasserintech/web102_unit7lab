{"ast":null,"code":"/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n */\n\n/**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */\nconst TO_BASE64URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split('');\n/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */\n\nconst IGNORE_BASE64URL = ' \\t\\n\\r='.split('');\n/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */\n\nconst FROM_BASE64URL = (() => {\n  const charMap = new Array(128);\n\n  for (let i = 0; i < charMap.length; i += 1) {\n    charMap[i] = -1;\n  }\n\n  for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {\n    charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\n  }\n\n  for (let i = 0; i < TO_BASE64URL.length; i += 1) {\n    charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\n  }\n\n  return charMap;\n})();\n/**\n * Converts a byte to a Base64-URL string.\n *\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next Base64 character when ready.\n */\n\n\nexport function byteToBase64URL(byte, state, emit) {\n  if (byte !== null) {\n    state.queue = state.queue << 8 | byte;\n    state.queuedBits += 8;\n\n    while (state.queuedBits >= 6) {\n      const pos = state.queue >> state.queuedBits - 6 & 63;\n      emit(TO_BASE64URL[pos]);\n      state.queuedBits -= 6;\n    }\n  } else if (state.queuedBits > 0) {\n    state.queue = state.queue << 6 - state.queuedBits;\n    state.queuedBits = 6;\n\n    while (state.queuedBits >= 6) {\n      const pos = state.queue >> state.queuedBits - 6 & 63;\n      emit(TO_BASE64URL[pos]);\n      state.queuedBits -= 6;\n    }\n  }\n}\n/**\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\n *\n * @param charCode The char code of the JavaScript string.\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next byte.\n */\n\nexport function byteFromBase64URL(charCode, state, emit) {\n  const bits = FROM_BASE64URL[charCode];\n\n  if (bits > -1) {\n    // valid Base64-URL character\n    state.queue = state.queue << 6 | bits;\n    state.queuedBits += 6;\n\n    while (state.queuedBits >= 8) {\n      emit(state.queue >> state.queuedBits - 8 & 0xff);\n      state.queuedBits -= 8;\n    }\n  } else if (bits === -2) {\n    // ignore spaces, tabs, newlines, =\n    return;\n  } else {\n    throw new Error(`Invalid Base64-URL character \"${String.fromCharCode(charCode)}\"`);\n  }\n}\n/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */\n\nexport function stringToBase64URL(str) {\n  const base64 = [];\n\n  const emitter = char => {\n    base64.push(char);\n  };\n\n  const state = {\n    queue: 0,\n    queuedBits: 0\n  };\n  stringToUTF8(str, byte => {\n    byteToBase64URL(byte, state, emitter);\n  });\n  byteToBase64URL(null, state, emitter);\n  return base64.join('');\n}\n/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */\n\nexport function stringFromBase64URL(str) {\n  const conv = [];\n\n  const utf8Emit = codepoint => {\n    conv.push(String.fromCodePoint(codepoint));\n  };\n\n  const utf8State = {\n    utf8seq: 0,\n    codepoint: 0\n  };\n  const b64State = {\n    queue: 0,\n    queuedBits: 0\n  };\n\n  const byteEmit = byte => {\n    stringFromUTF8(byte, utf8State, utf8Emit);\n  };\n\n  for (let i = 0; i < str.length; i += 1) {\n    byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);\n  }\n\n  return conv.join('');\n}\n/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */\n\nexport function codepointToUTF8(codepoint, emit) {\n  if (codepoint <= 0x7f) {\n    emit(codepoint);\n    return;\n  } else if (codepoint <= 0x7ff) {\n    emit(0xc0 | codepoint >> 6);\n    emit(0x80 | codepoint & 0x3f);\n    return;\n  } else if (codepoint <= 0xffff) {\n    emit(0xe0 | codepoint >> 12);\n    emit(0x80 | codepoint >> 6 & 0x3f);\n    emit(0x80 | codepoint & 0x3f);\n    return;\n  } else if (codepoint <= 0x10ffff) {\n    emit(0xf0 | codepoint >> 18);\n    emit(0x80 | codepoint >> 12 & 0x3f);\n    emit(0x80 | codepoint >> 6 & 0x3f);\n    emit(0x80 | codepoint & 0x3f);\n    return;\n  }\n\n  throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);\n}\n/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */\n\nexport function stringToUTF8(str, emit) {\n  for (let i = 0; i < str.length; i += 1) {\n    let codepoint = str.charCodeAt(i);\n\n    if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n      // most UTF-16 codepoints are Unicode codepoints, except values in this\n      // range where the next UTF-16 codepoint needs to be combined with the\n      // current one to get the Unicode codepoint\n      const highSurrogate = (codepoint - 0xd800) * 0x400 & 0xffff;\n      const lowSurrogate = str.charCodeAt(i + 1) - 0xdc00 & 0xffff;\n      codepoint = (lowSurrogate | highSurrogate) + 0x10000;\n      i += 1;\n    }\n\n    codepointToUTF8(codepoint, emit);\n  }\n}\n/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */\n\nexport function stringFromUTF8(byte, state, emit) {\n  if (state.utf8seq === 0) {\n    if (byte <= 0x7f) {\n      emit(byte);\n      return;\n    } // count the number of 1 leading bits until you reach 0\n\n\n    for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {\n      if ((byte >> 7 - leadingBit & 1) === 0) {\n        state.utf8seq = leadingBit;\n        break;\n      }\n    }\n\n    if (state.utf8seq === 2) {\n      state.codepoint = byte & 31;\n    } else if (state.utf8seq === 3) {\n      state.codepoint = byte & 15;\n    } else if (state.utf8seq === 4) {\n      state.codepoint = byte & 7;\n    } else {\n      throw new Error('Invalid UTF-8 sequence');\n    }\n\n    state.utf8seq -= 1;\n  } else if (state.utf8seq > 0) {\n    if (byte <= 0x7f) {\n      throw new Error('Invalid UTF-8 sequence');\n    }\n\n    state.codepoint = state.codepoint << 6 | byte & 63;\n    state.utf8seq -= 1;\n\n    if (state.utf8seq === 0) {\n      emit(state.codepoint);\n    }\n  }\n}\n/**\n * Helper functions to convert different types of strings to Uint8Array\n */\n\nexport function base64UrlToUint8Array(str) {\n  const result = [];\n  const state = {\n    queue: 0,\n    queuedBits: 0\n  };\n\n  const onByte = byte => {\n    result.push(byte);\n  };\n\n  for (let i = 0; i < str.length; i += 1) {\n    byteFromBase64URL(str.charCodeAt(i), state, onByte);\n  }\n\n  return new Uint8Array(result);\n}\nexport function stringToUint8Array(str) {\n  const result = [];\n  stringToUTF8(str, byte => result.push(byte));\n  return new Uint8Array(result);\n}","map":{"version":3,"mappings":"AAAA;;;;;;AAMA;;;;AAIA,MAAMA,YAAY,GAAG,mEAAmEC,KAAnE,CAAyE,EAAzE,CAArB;AAEA;;;;;AAIA,MAAMC,gBAAgB,GAAG,WAAWD,KAAX,CAAiB,EAAjB,CAAzB;AAEA;;;;;AAIA,MAAME,cAAc,GAAG,CAAC,MAAK;EAC3B,MAAMC,OAAO,GAAa,IAAIC,KAAJ,CAAU,GAAV,CAA1B;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,OAAO,CAACG,MAA5B,EAAoCD,CAAC,IAAI,CAAzC,EAA4C;IAC1CF,OAAO,CAACE,CAAD,CAAP,GAAa,CAAC,CAAd;EACD;;EAED,KAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,gBAAgB,CAACK,MAArC,EAA6CD,CAAC,IAAI,CAAlD,EAAqD;IACnDF,OAAO,CAACF,gBAAgB,CAACI,CAAD,CAAhB,CAAoBE,UAApB,CAA+B,CAA/B,CAAD,CAAP,GAA6C,CAAC,CAA9C;EACD;;EAED,KAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,YAAY,CAACO,MAAjC,EAAyCD,CAAC,IAAI,CAA9C,EAAiD;IAC/CF,OAAO,CAACJ,YAAY,CAACM,CAAD,CAAZ,CAAgBE,UAAhB,CAA2B,CAA3B,CAAD,CAAP,GAAyCF,CAAzC;EACD;;EAED,OAAOF,OAAP;AACD,CAhBsB,GAAvB;AAkBA;;;;;;;;;AAOA,OAAM,SAAUK,eAAV,CACJC,IADI,EAEJC,KAFI,EAGJC,IAHI,EAGwB;EAE5B,IAAIF,IAAI,KAAK,IAAb,EAAmB;IACjBC,KAAK,CAACE,KAAN,GAAeF,KAAK,CAACE,KAAN,IAAe,CAAhB,GAAqBH,IAAnC;IACAC,KAAK,CAACG,UAAN,IAAoB,CAApB;;IAEA,OAAOH,KAAK,CAACG,UAAN,IAAoB,CAA3B,EAA8B;MAC5B,MAAMC,GAAG,GAAIJ,KAAK,CAACE,KAAN,IAAgBF,KAAK,CAACG,UAAN,GAAmB,CAApC,GAA0C,EAAtD;MACAF,IAAI,CAACZ,YAAY,CAACe,GAAD,CAAb,CAAJ;MACAJ,KAAK,CAACG,UAAN,IAAoB,CAApB;IACD;EACF,CATD,MASO,IAAIH,KAAK,CAACG,UAAN,GAAmB,CAAvB,EAA0B;IAC/BH,KAAK,CAACE,KAAN,GAAcF,KAAK,CAACE,KAAN,IAAgB,IAAIF,KAAK,CAACG,UAAxC;IACAH,KAAK,CAACG,UAAN,GAAmB,CAAnB;;IAEA,OAAOH,KAAK,CAACG,UAAN,IAAoB,CAA3B,EAA8B;MAC5B,MAAMC,GAAG,GAAIJ,KAAK,CAACE,KAAN,IAAgBF,KAAK,CAACG,UAAN,GAAmB,CAApC,GAA0C,EAAtD;MACAF,IAAI,CAACZ,YAAY,CAACe,GAAD,CAAb,CAAJ;MACAJ,KAAK,CAACG,UAAN,IAAoB,CAApB;IACD;EACF;AACF;AAED;;;;;;;;AAOA,OAAM,SAAUE,iBAAV,CACJC,QADI,EAEJN,KAFI,EAGJC,IAHI,EAGwB;EAE5B,MAAMM,IAAI,GAAGf,cAAc,CAACc,QAAD,CAA3B;;EAEA,IAAIC,IAAI,GAAG,CAAC,CAAZ,EAAe;IACb;IACAP,KAAK,CAACE,KAAN,GAAeF,KAAK,CAACE,KAAN,IAAe,CAAhB,GAAqBK,IAAnC;IACAP,KAAK,CAACG,UAAN,IAAoB,CAApB;;IAEA,OAAOH,KAAK,CAACG,UAAN,IAAoB,CAA3B,EAA8B;MAC5BF,IAAI,CAAED,KAAK,CAACE,KAAN,IAAgBF,KAAK,CAACG,UAAN,GAAmB,CAApC,GAA0C,IAA3C,CAAJ;MACAH,KAAK,CAACG,UAAN,IAAoB,CAApB;IACD;EACF,CATD,MASO,IAAII,IAAI,KAAK,CAAC,CAAd,EAAiB;IACtB;IACA;EACD,CAHM,MAGA;IACL,MAAM,IAAIC,KAAJ,CAAU,iCAAiCC,MAAM,CAACC,YAAP,CAAoBJ,QAApB,CAA6B,GAAxE,CAAN;EACD;AACF;AAED;;;;;;;;AAOA,OAAM,SAAUK,iBAAV,CAA4BC,GAA5B,EAAuC;EAC3C,MAAMC,MAAM,GAAa,EAAzB;;EAEA,MAAMC,OAAO,GAAIC,IAAD,IAAiB;IAC/BF,MAAM,CAACG,IAAP,CAAYD,IAAZ;EACD,CAFD;;EAIA,MAAMf,KAAK,GAAG;IAAEE,KAAK,EAAE,CAAT;IAAYC,UAAU,EAAE;EAAxB,CAAd;EAEAc,YAAY,CAACL,GAAD,EAAOb,IAAD,IAAiB;IACjCD,eAAe,CAACC,IAAD,EAAOC,KAAP,EAAcc,OAAd,CAAf;EACD,CAFW,CAAZ;EAIAhB,eAAe,CAAC,IAAD,EAAOE,KAAP,EAAcc,OAAd,CAAf;EAEA,OAAOD,MAAM,CAACK,IAAP,CAAY,EAAZ,CAAP;AACD;AAED;;;;;;;AAMA,OAAM,SAAUC,mBAAV,CAA8BP,GAA9B,EAAyC;EAC7C,MAAMQ,IAAI,GAAa,EAAvB;;EAEA,MAAMC,QAAQ,GAAIC,SAAD,IAAsB;IACrCF,IAAI,CAACJ,IAAL,CAAUP,MAAM,CAACc,aAAP,CAAqBD,SAArB,CAAV;EACD,CAFD;;EAIA,MAAME,SAAS,GAAG;IAChBC,OAAO,EAAE,CADO;IAEhBH,SAAS,EAAE;EAFK,CAAlB;EAKA,MAAMI,QAAQ,GAAG;IAAExB,KAAK,EAAE,CAAT;IAAYC,UAAU,EAAE;EAAxB,CAAjB;;EAEA,MAAMwB,QAAQ,GAAI5B,IAAD,IAAiB;IAChC6B,cAAc,CAAC7B,IAAD,EAAOyB,SAAP,EAAkBH,QAAlB,CAAd;EACD,CAFD;;EAIA,KAAK,IAAI1B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiB,GAAG,CAAChB,MAAxB,EAAgCD,CAAC,IAAI,CAArC,EAAwC;IACtCU,iBAAiB,CAACO,GAAG,CAACf,UAAJ,CAAeF,CAAf,CAAD,EAAoB+B,QAApB,EAA8BC,QAA9B,CAAjB;EACD;;EAED,OAAOP,IAAI,CAACF,IAAL,CAAU,EAAV,CAAP;AACD;AAED;;;;;;;AAMA,OAAM,SAAUW,eAAV,CAA0BP,SAA1B,EAA6CrB,IAA7C,EAAyE;EAC7E,IAAIqB,SAAS,IAAI,IAAjB,EAAuB;IACrBrB,IAAI,CAACqB,SAAD,CAAJ;IACA;EACD,CAHD,MAGO,IAAIA,SAAS,IAAI,KAAjB,EAAwB;IAC7BrB,IAAI,CAAC,OAAQqB,SAAS,IAAI,CAAtB,CAAJ;IACArB,IAAI,CAAC,OAAQqB,SAAS,GAAG,IAArB,CAAJ;IACA;EACD,CAJM,MAIA,IAAIA,SAAS,IAAI,MAAjB,EAAyB;IAC9BrB,IAAI,CAAC,OAAQqB,SAAS,IAAI,EAAtB,CAAJ;IACArB,IAAI,CAAC,OAASqB,SAAS,IAAI,CAAd,GAAmB,IAA5B,CAAJ;IACArB,IAAI,CAAC,OAAQqB,SAAS,GAAG,IAArB,CAAJ;IACA;EACD,CALM,MAKA,IAAIA,SAAS,IAAI,QAAjB,EAA2B;IAChCrB,IAAI,CAAC,OAAQqB,SAAS,IAAI,EAAtB,CAAJ;IACArB,IAAI,CAAC,OAASqB,SAAS,IAAI,EAAd,GAAoB,IAA7B,CAAJ;IACArB,IAAI,CAAC,OAASqB,SAAS,IAAI,CAAd,GAAmB,IAA5B,CAAJ;IACArB,IAAI,CAAC,OAAQqB,SAAS,GAAG,IAArB,CAAJ;IACA;EACD;;EAED,MAAM,IAAId,KAAJ,CAAU,mCAAmCc,SAAS,CAACQ,QAAV,CAAmB,EAAnB,CAAsB,EAAnE,CAAN;AACD;AAED;;;;;;;AAMA,OAAM,SAAUb,YAAV,CAAuBL,GAAvB,EAAoCX,IAApC,EAAgE;EACpE,KAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiB,GAAG,CAAChB,MAAxB,EAAgCD,CAAC,IAAI,CAArC,EAAwC;IACtC,IAAI2B,SAAS,GAAGV,GAAG,CAACf,UAAJ,CAAeF,CAAf,CAAhB;;IAEA,IAAI2B,SAAS,GAAG,MAAZ,IAAsBA,SAAS,IAAI,MAAvC,EAA+C;MAC7C;MACA;MACA;MACA,MAAMS,aAAa,GAAI,CAACT,SAAS,GAAG,MAAb,IAAuB,KAAxB,GAAiC,MAAvD;MACA,MAAMU,YAAY,GAAIpB,GAAG,CAACf,UAAJ,CAAeF,CAAC,GAAG,CAAnB,IAAwB,MAAzB,GAAmC,MAAxD;MACA2B,SAAS,GAAG,CAACU,YAAY,GAAGD,aAAhB,IAAiC,OAA7C;MACApC,CAAC,IAAI,CAAL;IACD;;IAEDkC,eAAe,CAACP,SAAD,EAAYrB,IAAZ,CAAf;EACD;AACF;AAED;;;;;;;;;AAQA,OAAM,SAAU2B,cAAV,CACJ7B,IADI,EAEJC,KAFI,EAGJC,IAHI,EAG6B;EAEjC,IAAID,KAAK,CAACyB,OAAN,KAAkB,CAAtB,EAAyB;IACvB,IAAI1B,IAAI,IAAI,IAAZ,EAAkB;MAChBE,IAAI,CAACF,IAAD,CAAJ;MACA;IACD,CAJsB,CAMvB;;;IACA,KAAK,IAAIkC,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAG,CAAtC,EAAyCA,UAAU,IAAI,CAAvD,EAA0D;MACxD,IAAI,CAAElC,IAAI,IAAK,IAAIkC,UAAd,GAA6B,CAA9B,MAAqC,CAAzC,EAA4C;QAC1CjC,KAAK,CAACyB,OAAN,GAAgBQ,UAAhB;QACA;MACD;IACF;;IAED,IAAIjC,KAAK,CAACyB,OAAN,KAAkB,CAAtB,EAAyB;MACvBzB,KAAK,CAACsB,SAAN,GAAkBvB,IAAI,GAAG,EAAzB;IACD,CAFD,MAEO,IAAIC,KAAK,CAACyB,OAAN,KAAkB,CAAtB,EAAyB;MAC9BzB,KAAK,CAACsB,SAAN,GAAkBvB,IAAI,GAAG,EAAzB;IACD,CAFM,MAEA,IAAIC,KAAK,CAACyB,OAAN,KAAkB,CAAtB,EAAyB;MAC9BzB,KAAK,CAACsB,SAAN,GAAkBvB,IAAI,GAAG,CAAzB;IACD,CAFM,MAEA;MACL,MAAM,IAAIS,KAAJ,CAAU,wBAAV,CAAN;IACD;;IAEDR,KAAK,CAACyB,OAAN,IAAiB,CAAjB;EACD,CAzBD,MAyBO,IAAIzB,KAAK,CAACyB,OAAN,GAAgB,CAApB,EAAuB;IAC5B,IAAI1B,IAAI,IAAI,IAAZ,EAAkB;MAChB,MAAM,IAAIS,KAAJ,CAAU,wBAAV,CAAN;IACD;;IAEDR,KAAK,CAACsB,SAAN,GAAmBtB,KAAK,CAACsB,SAAN,IAAmB,CAApB,GAA0BvB,IAAI,GAAG,EAAnD;IACAC,KAAK,CAACyB,OAAN,IAAiB,CAAjB;;IAEA,IAAIzB,KAAK,CAACyB,OAAN,KAAkB,CAAtB,EAAyB;MACvBxB,IAAI,CAACD,KAAK,CAACsB,SAAP,CAAJ;IACD;EACF;AACF;AAED;;;;AAIA,OAAM,SAAUY,qBAAV,CAAgCtB,GAAhC,EAA2C;EAC/C,MAAMuB,MAAM,GAAa,EAAzB;EACA,MAAMnC,KAAK,GAAG;IAAEE,KAAK,EAAE,CAAT;IAAYC,UAAU,EAAE;EAAxB,CAAd;;EAEA,MAAMiC,MAAM,GAAIrC,IAAD,IAAiB;IAC9BoC,MAAM,CAACnB,IAAP,CAAYjB,IAAZ;EACD,CAFD;;EAIA,KAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiB,GAAG,CAAChB,MAAxB,EAAgCD,CAAC,IAAI,CAArC,EAAwC;IACtCU,iBAAiB,CAACO,GAAG,CAACf,UAAJ,CAAeF,CAAf,CAAD,EAAoBK,KAApB,EAA2BoC,MAA3B,CAAjB;EACD;;EAED,OAAO,IAAIC,UAAJ,CAAeF,MAAf,CAAP;AACD;AAED,OAAM,SAAUG,kBAAV,CAA6B1B,GAA7B,EAAwC;EAC5C,MAAMuB,MAAM,GAAa,EAAzB;EACAlB,YAAY,CAACL,GAAD,EAAOb,IAAD,IAAkBoC,MAAM,CAACnB,IAAP,CAAYjB,IAAZ,CAAxB,CAAZ;EACA,OAAO,IAAIsC,UAAJ,CAAeF,MAAf,CAAP;AACD","names":["TO_BASE64URL","split","IGNORE_BASE64URL","FROM_BASE64URL","charMap","Array","i","length","charCodeAt","byteToBase64URL","byte","state","emit","queue","queuedBits","pos","byteFromBase64URL","charCode","bits","Error","String","fromCharCode","stringToBase64URL","str","base64","emitter","char","push","stringToUTF8","join","stringFromBase64URL","conv","utf8Emit","codepoint","fromCodePoint","utf8State","utf8seq","b64State","byteEmit","stringFromUTF8","codepointToUTF8","toString","highSurrogate","lowSurrogate","leadingBit","base64UrlToUint8Array","result","onByte","Uint8Array","stringToUint8Array"],"sources":["/Users/grove/Desktop/repos/web102_unit7lab/client/node_modules/@supabase/auth-js/src/lib/base64url.ts"],"sourcesContent":["/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n */\n\n/**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */\nconst TO_BASE64URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split('')\n\n/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */\nconst IGNORE_BASE64URL = ' \\t\\n\\r='.split('')\n\n/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */\nconst FROM_BASE64URL = (() => {\n  const charMap: number[] = new Array(128)\n\n  for (let i = 0; i < charMap.length; i += 1) {\n    charMap[i] = -1\n  }\n\n  for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {\n    charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2\n  }\n\n  for (let i = 0; i < TO_BASE64URL.length; i += 1) {\n    charMap[TO_BASE64URL[i].charCodeAt(0)] = i\n  }\n\n  return charMap\n})()\n\n/**\n * Converts a byte to a Base64-URL string.\n *\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next Base64 character when ready.\n */\nexport function byteToBase64URL(\n  byte: number | null,\n  state: { queue: number; queuedBits: number },\n  emit: (char: string) => void\n) {\n  if (byte !== null) {\n    state.queue = (state.queue << 8) | byte\n    state.queuedBits += 8\n\n    while (state.queuedBits >= 6) {\n      const pos = (state.queue >> (state.queuedBits - 6)) & 63\n      emit(TO_BASE64URL[pos])\n      state.queuedBits -= 6\n    }\n  } else if (state.queuedBits > 0) {\n    state.queue = state.queue << (6 - state.queuedBits)\n    state.queuedBits = 6\n\n    while (state.queuedBits >= 6) {\n      const pos = (state.queue >> (state.queuedBits - 6)) & 63\n      emit(TO_BASE64URL[pos])\n      state.queuedBits -= 6\n    }\n  }\n}\n\n/**\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\n *\n * @param charCode The char code of the JavaScript string.\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next byte.\n */\nexport function byteFromBase64URL(\n  charCode: number,\n  state: { queue: number; queuedBits: number },\n  emit: (byte: number) => void\n) {\n  const bits = FROM_BASE64URL[charCode]\n\n  if (bits > -1) {\n    // valid Base64-URL character\n    state.queue = (state.queue << 6) | bits\n    state.queuedBits += 6\n\n    while (state.queuedBits >= 8) {\n      emit((state.queue >> (state.queuedBits - 8)) & 0xff)\n      state.queuedBits -= 8\n    }\n  } else if (bits === -2) {\n    // ignore spaces, tabs, newlines, =\n    return\n  } else {\n    throw new Error(`Invalid Base64-URL character \"${String.fromCharCode(charCode)}\"`)\n  }\n}\n\n/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */\nexport function stringToBase64URL(str: string) {\n  const base64: string[] = []\n\n  const emitter = (char: string) => {\n    base64.push(char)\n  }\n\n  const state = { queue: 0, queuedBits: 0 }\n\n  stringToUTF8(str, (byte: number) => {\n    byteToBase64URL(byte, state, emitter)\n  })\n\n  byteToBase64URL(null, state, emitter)\n\n  return base64.join('')\n}\n\n/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */\nexport function stringFromBase64URL(str: string) {\n  const conv: string[] = []\n\n  const utf8Emit = (codepoint: number) => {\n    conv.push(String.fromCodePoint(codepoint))\n  }\n\n  const utf8State = {\n    utf8seq: 0,\n    codepoint: 0,\n  }\n\n  const b64State = { queue: 0, queuedBits: 0 }\n\n  const byteEmit = (byte: number) => {\n    stringFromUTF8(byte, utf8State, utf8Emit)\n  }\n\n  for (let i = 0; i < str.length; i += 1) {\n    byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit)\n  }\n\n  return conv.join('')\n}\n\n/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */\nexport function codepointToUTF8(codepoint: number, emit: (byte: number) => void) {\n  if (codepoint <= 0x7f) {\n    emit(codepoint)\n    return\n  } else if (codepoint <= 0x7ff) {\n    emit(0xc0 | (codepoint >> 6))\n    emit(0x80 | (codepoint & 0x3f))\n    return\n  } else if (codepoint <= 0xffff) {\n    emit(0xe0 | (codepoint >> 12))\n    emit(0x80 | ((codepoint >> 6) & 0x3f))\n    emit(0x80 | (codepoint & 0x3f))\n    return\n  } else if (codepoint <= 0x10ffff) {\n    emit(0xf0 | (codepoint >> 18))\n    emit(0x80 | ((codepoint >> 12) & 0x3f))\n    emit(0x80 | ((codepoint >> 6) & 0x3f))\n    emit(0x80 | (codepoint & 0x3f))\n    return\n  }\n\n  throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`)\n}\n\n/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */\nexport function stringToUTF8(str: string, emit: (byte: number) => void) {\n  for (let i = 0; i < str.length; i += 1) {\n    let codepoint = str.charCodeAt(i)\n\n    if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n      // most UTF-16 codepoints are Unicode codepoints, except values in this\n      // range where the next UTF-16 codepoint needs to be combined with the\n      // current one to get the Unicode codepoint\n      const highSurrogate = ((codepoint - 0xd800) * 0x400) & 0xffff\n      const lowSurrogate = (str.charCodeAt(i + 1) - 0xdc00) & 0xffff\n      codepoint = (lowSurrogate | highSurrogate) + 0x10000\n      i += 1\n    }\n\n    codepointToUTF8(codepoint, emit)\n  }\n}\n\n/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */\nexport function stringFromUTF8(\n  byte: number,\n  state: { utf8seq: number; codepoint: number },\n  emit: (codepoint: number) => void\n) {\n  if (state.utf8seq === 0) {\n    if (byte <= 0x7f) {\n      emit(byte)\n      return\n    }\n\n    // count the number of 1 leading bits until you reach 0\n    for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {\n      if (((byte >> (7 - leadingBit)) & 1) === 0) {\n        state.utf8seq = leadingBit\n        break\n      }\n    }\n\n    if (state.utf8seq === 2) {\n      state.codepoint = byte & 31\n    } else if (state.utf8seq === 3) {\n      state.codepoint = byte & 15\n    } else if (state.utf8seq === 4) {\n      state.codepoint = byte & 7\n    } else {\n      throw new Error('Invalid UTF-8 sequence')\n    }\n\n    state.utf8seq -= 1\n  } else if (state.utf8seq > 0) {\n    if (byte <= 0x7f) {\n      throw new Error('Invalid UTF-8 sequence')\n    }\n\n    state.codepoint = (state.codepoint << 6) | (byte & 63)\n    state.utf8seq -= 1\n\n    if (state.utf8seq === 0) {\n      emit(state.codepoint)\n    }\n  }\n}\n\n/**\n * Helper functions to convert different types of strings to Uint8Array\n */\n\nexport function base64UrlToUint8Array(str: string): Uint8Array {\n  const result: number[] = []\n  const state = { queue: 0, queuedBits: 0 }\n\n  const onByte = (byte: number) => {\n    result.push(byte)\n  }\n\n  for (let i = 0; i < str.length; i += 1) {\n    byteFromBase64URL(str.charCodeAt(i), state, onByte)\n  }\n\n  return new Uint8Array(result)\n}\n\nexport function stringToUint8Array(str: string): Uint8Array {\n  const result: number[] = []\n  stringToUTF8(str, (byte: number) => result.push(byte))\n  return new Uint8Array(result)\n}\n"]},"metadata":{},"sourceType":"module"}