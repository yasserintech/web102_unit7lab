{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { FunctionsClient } from '@supabase/functions-js';\nimport { PostgrestClient } from '@supabase/postgrest-js';\nimport { RealtimeClient } from '@supabase/realtime-js';\nimport { StorageClient as SupabaseStorageClient } from '@supabase/storage-js';\nimport { DEFAULT_GLOBAL_OPTIONS, DEFAULT_DB_OPTIONS, DEFAULT_AUTH_OPTIONS, DEFAULT_REALTIME_OPTIONS } from './lib/constants';\nimport { fetchWithAuth } from './lib/fetch';\nimport { stripTrailingSlash, applySettingDefaults } from './lib/helpers';\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient';\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\n\nexport default class SupabaseClient {\n  /**\n   * Create a new client for use in the browser.\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n   * @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.realtime Options passed along to realtime-js constructor.\n   * @param options.global.fetch A custom fetch implementation.\n   * @param options.global.headers Any additional headers to send with each network request.\n   */\n  constructor(supabaseUrl, supabaseKey, options) {\n    var _a, _b, _c;\n\n    this.supabaseUrl = supabaseUrl;\n    this.supabaseKey = supabaseKey;\n    if (!supabaseUrl) throw new Error('supabaseUrl is required.');\n    if (!supabaseKey) throw new Error('supabaseKey is required.');\n\n    const _supabaseUrl = stripTrailingSlash(supabaseUrl);\n\n    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, 'ws');\n    this.authUrl = `${_supabaseUrl}/auth/v1`;\n    this.storageUrl = `${_supabaseUrl}/storage/v1`;\n    this.functionsUrl = `${_supabaseUrl}/functions/v1`; // default storage key uses the supabase project ref as a namespace\n\n    const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split('.')[0]}-auth-token`;\n    const DEFAULTS = {\n      db: DEFAULT_DB_OPTIONS,\n      realtime: DEFAULT_REALTIME_OPTIONS,\n      auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), {\n        storageKey: defaultStorageKey\n      }),\n      global: DEFAULT_GLOBAL_OPTIONS\n    };\n    const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);\n    this.storageKey = (_a = settings.auth.storageKey) !== null && _a !== void 0 ? _a : '';\n    this.headers = (_b = settings.global.headers) !== null && _b !== void 0 ? _b : {};\n\n    if (!settings.accessToken) {\n      this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== void 0 ? _c : {}, this.headers, settings.global.fetch);\n    } else {\n      this.accessToken = settings.accessToken;\n      this.auth = new Proxy({}, {\n        get: (_, prop) => {\n          throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);\n        }\n      });\n    }\n\n    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);\n    this.realtime = this._initRealtimeClient(Object.assign({\n      headers: this.headers,\n      accessToken: this._getAccessToken.bind(this)\n    }, settings.realtime));\n    this.rest = new PostgrestClient(`${_supabaseUrl}/rest/v1`, {\n      headers: this.headers,\n      schema: settings.db.schema,\n      fetch: this.fetch\n    });\n\n    if (!settings.accessToken) {\n      this._listenForAuthEvents();\n    }\n  }\n  /**\n   * Supabase Functions allows you to deploy and invoke edge functions.\n   */\n\n\n  get functions() {\n    return new FunctionsClient(this.functionsUrl, {\n      headers: this.headers,\n      customFetch: this.fetch\n    });\n  }\n  /**\n   * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n   */\n\n\n  get storage() {\n    return new SupabaseStorageClient(this.storageUrl, this.headers, this.fetch);\n  }\n  /**\n   * Perform a query on a table or a view.\n   *\n   * @param relation - The table or view name to query\n   */\n\n\n  from(relation) {\n    return this.rest.from(relation);\n  } // NOTE: signatures must be kept in sync with PostgrestClient.schema\n\n  /**\n   * Select a schema to query or perform an function (rpc) call.\n   *\n   * The schema needs to be on the list of exposed schemas inside Supabase.\n   *\n   * @param schema - The schema to query\n   */\n\n\n  schema(schema) {\n    return this.rest.schema(schema);\n  } // NOTE: signatures must be kept in sync with PostgrestClient.rpc\n\n  /**\n   * Perform a function call.\n   *\n   * @param fn - The function name to call\n   * @param args - The arguments to pass to the function call\n   * @param options - Named parameters\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   * @param options.get - When set to `true`, the function will be called with\n   * read-only access mode.\n   * @param options.count - Count algorithm to use to count rows returned by the\n   * function. Only applicable for [set-returning\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n\n\n  rpc(fn) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.rest.rpc(fn, args, options);\n  }\n  /**\n   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\n   *\n   * @param {string} name - The name of the Realtime channel.\n   * @param {Object} opts - The options to pass to the Realtime channel.\n   *\n   */\n\n\n  channel(name) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      config: {}\n    };\n    return this.realtime.channel(name, opts);\n  }\n  /**\n   * Returns all Realtime channels.\n   */\n\n\n  getChannels() {\n    return this.realtime.getChannels();\n  }\n  /**\n   * Unsubscribes and removes Realtime channel from Realtime client.\n   *\n   * @param {RealtimeChannel} channel - The name of the Realtime channel.\n   *\n   */\n\n\n  removeChannel(channel) {\n    return this.realtime.removeChannel(channel);\n  }\n  /**\n   * Unsubscribes and removes all Realtime channels from Realtime client.\n   */\n\n\n  removeAllChannels() {\n    return this.realtime.removeAllChannels();\n  }\n\n  _getAccessToken() {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.accessToken) {\n        return yield this.accessToken();\n      }\n\n      const {\n        data\n      } = yield this.auth.getSession();\n      return (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : null;\n    });\n  }\n\n  _initSupabaseAuthClient(_ref, headers, fetch) {\n    let {\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      storageKey,\n      flowType,\n      lock,\n      debug\n    } = _ref;\n    const authHeaders = {\n      Authorization: `Bearer ${this.supabaseKey}`,\n      apikey: `${this.supabaseKey}`\n    };\n    return new SupabaseAuthClient({\n      url: this.authUrl,\n      headers: Object.assign(Object.assign({}, authHeaders), headers),\n      storageKey: storageKey,\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      flowType,\n      lock,\n      debug,\n      fetch,\n      // auth checks if there is a custom authorizaiton header using this flag\n      // so it knows whether to return an error when getUser is called with no session\n      hasCustomAuthorizationHeader: 'Authorization' in this.headers\n    });\n  }\n\n  _initRealtimeClient(options) {\n    return new RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), {\n      params: Object.assign({\n        apikey: this.supabaseKey\n      }, options === null || options === void 0 ? void 0 : options.params)\n    }));\n  }\n\n  _listenForAuthEvents() {\n    let data = this.auth.onAuthStateChange((event, session) => {\n      this._handleTokenChanged(event, 'CLIENT', session === null || session === void 0 ? void 0 : session.access_token);\n    });\n    return data;\n  }\n\n  _handleTokenChanged(event, source, token) {\n    if ((event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') && this.changedAccessToken !== token) {\n      this.changedAccessToken = token;\n    } else if (event === 'SIGNED_OUT') {\n      this.realtime.setAuth();\n      if (source == 'STORAGE') this.auth.signOut();\n      this.changedAccessToken = undefined;\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["FunctionsClient","PostgrestClient","RealtimeClient","StorageClient","SupabaseStorageClient","DEFAULT_GLOBAL_OPTIONS","DEFAULT_DB_OPTIONS","DEFAULT_AUTH_OPTIONS","DEFAULT_REALTIME_OPTIONS","fetchWithAuth","stripTrailingSlash","applySettingDefaults","SupabaseAuthClient","SupabaseClient","constructor","supabaseUrl","supabaseKey","options","Error","_supabaseUrl","realtimeUrl","replace","authUrl","storageUrl","functionsUrl","defaultStorageKey","URL","hostname","split","DEFAULTS","db","realtime","auth","storageKey","global","settings","_a","headers","_b","accessToken","_initSupabaseAuthClient","_c","fetch","Proxy","get","_","prop","String","_getAccessToken","bind","_initRealtimeClient","Object","rest","schema","_listenForAuthEvents","functions","customFetch","storage","from","relation","rpc","fn","args","channel","name","opts","config","getChannels","removeChannel","removeAllChannels","data","getSession","session","access_token","autoRefreshToken","persistSession","detectSessionInUrl","flowType","lock","debug","authHeaders","Authorization","apikey","url","hasCustomAuthorizationHeader","params","onAuthStateChange","event","_handleTokenChanged","source","token","changedAccessToken","setAuth","signOut","undefined"],"sources":["/Users/grove/Desktop/repos/web102_unit7lab/client/node_modules/@supabase/supabase-js/src/SupabaseClient.ts"],"sourcesContent":["import { FunctionsClient } from '@supabase/functions-js'\nimport { AuthChangeEvent } from '@supabase/auth-js'\nimport {\n  PostgrestClient,\n  PostgrestFilterBuilder,\n  PostgrestQueryBuilder,\n} from '@supabase/postgrest-js'\nimport {\n  RealtimeChannel,\n  RealtimeChannelOptions,\n  RealtimeClient,\n  RealtimeClientOptions,\n} from '@supabase/realtime-js'\nimport { StorageClient as SupabaseStorageClient } from '@supabase/storage-js'\nimport {\n  DEFAULT_GLOBAL_OPTIONS,\n  DEFAULT_DB_OPTIONS,\n  DEFAULT_AUTH_OPTIONS,\n  DEFAULT_REALTIME_OPTIONS,\n} from './lib/constants'\nimport { fetchWithAuth } from './lib/fetch'\nimport { stripTrailingSlash, applySettingDefaults } from './lib/helpers'\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient'\nimport { Fetch, GenericSchema, SupabaseClientOptions, SupabaseAuthClientOptions } from './lib/types'\n\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\nexport default class SupabaseClient<\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database,\n  Schema extends GenericSchema = Database[SchemaName] extends GenericSchema\n    ? Database[SchemaName]\n    : any\n> {\n  /**\n   * Supabase Auth allows you to create and manage user sessions for access to data that is secured by access policies.\n   */\n  auth: SupabaseAuthClient\n  realtime: RealtimeClient\n\n  protected realtimeUrl: string\n  protected authUrl: string\n  protected storageUrl: string\n  protected functionsUrl: string\n  protected rest: PostgrestClient<Database, SchemaName, Schema>\n  protected storageKey: string\n  protected fetch?: Fetch\n  protected changedAccessToken?: string\n  protected accessToken?: () => Promise<string | null>\n\n  protected headers: Record<string, string>\n\n  /**\n   * Create a new client for use in the browser.\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n   * @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.realtime Options passed along to realtime-js constructor.\n   * @param options.global.fetch A custom fetch implementation.\n   * @param options.global.headers Any additional headers to send with each network request.\n   */\n  constructor(\n    protected supabaseUrl: string,\n    protected supabaseKey: string,\n    options?: SupabaseClientOptions<SchemaName>\n  ) {\n    if (!supabaseUrl) throw new Error('supabaseUrl is required.')\n    if (!supabaseKey) throw new Error('supabaseKey is required.')\n\n    const _supabaseUrl = stripTrailingSlash(supabaseUrl)\n\n    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, 'ws')\n    this.authUrl = `${_supabaseUrl}/auth/v1`\n    this.storageUrl = `${_supabaseUrl}/storage/v1`\n    this.functionsUrl = `${_supabaseUrl}/functions/v1`\n\n    // default storage key uses the supabase project ref as a namespace\n    const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split('.')[0]}-auth-token`\n    const DEFAULTS = {\n      db: DEFAULT_DB_OPTIONS,\n      realtime: DEFAULT_REALTIME_OPTIONS,\n      auth: { ...DEFAULT_AUTH_OPTIONS, storageKey: defaultStorageKey },\n      global: DEFAULT_GLOBAL_OPTIONS,\n    }\n\n    const settings = applySettingDefaults(options ?? {}, DEFAULTS)\n\n    this.storageKey = settings.auth.storageKey ?? ''\n    this.headers = settings.global.headers ?? {}\n\n    if (!settings.accessToken) {\n      this.auth = this._initSupabaseAuthClient(\n        settings.auth ?? {},\n        this.headers,\n        settings.global.fetch\n      )\n    } else {\n      this.accessToken = settings.accessToken\n\n      this.auth = new Proxy<SupabaseAuthClient>({} as any, {\n        get: (_, prop) => {\n          throw new Error(\n            `@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(\n              prop\n            )} is not possible`\n          )\n        },\n      })\n    }\n\n    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch)\n    this.realtime = this._initRealtimeClient({\n      headers: this.headers,\n      accessToken: this._getAccessToken.bind(this),\n      ...settings.realtime,\n    })\n    this.rest = new PostgrestClient(`${_supabaseUrl}/rest/v1`, {\n      headers: this.headers,\n      schema: settings.db.schema,\n      fetch: this.fetch,\n    })\n\n    if (!settings.accessToken) {\n      this._listenForAuthEvents()\n    }\n  }\n\n  /**\n   * Supabase Functions allows you to deploy and invoke edge functions.\n   */\n  get functions(): FunctionsClient {\n    return new FunctionsClient(this.functionsUrl, {\n      headers: this.headers,\n      customFetch: this.fetch,\n    })\n  }\n\n  /**\n   * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n   */\n  get storage(): SupabaseStorageClient {\n    return new SupabaseStorageClient(this.storageUrl, this.headers, this.fetch)\n  }\n\n  // NOTE: signatures must be kept in sync with PostgrestClient.from\n  from<\n    TableName extends string & keyof Schema['Tables'],\n    Table extends Schema['Tables'][TableName]\n  >(relation: TableName): PostgrestQueryBuilder<Schema, Table, TableName>\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\n    relation: ViewName\n  ): PostgrestQueryBuilder<Schema, View, ViewName>\n  /**\n   * Perform a query on a table or a view.\n   *\n   * @param relation - The table or view name to query\n   */\n  from(relation: string): PostgrestQueryBuilder<Schema, any, any> {\n    return this.rest.from(relation)\n  }\n\n  // NOTE: signatures must be kept in sync with PostgrestClient.schema\n  /**\n   * Select a schema to query or perform an function (rpc) call.\n   *\n   * The schema needs to be on the list of exposed schemas inside Supabase.\n   *\n   * @param schema - The schema to query\n   */\n  schema<DynamicSchema extends string & keyof Database>(\n    schema: DynamicSchema\n  ): PostgrestClient<\n    Database,\n    DynamicSchema,\n    Database[DynamicSchema] extends GenericSchema ? Database[DynamicSchema] : any\n  > {\n    return this.rest.schema<DynamicSchema>(schema)\n  }\n\n  // NOTE: signatures must be kept in sync with PostgrestClient.rpc\n  /**\n   * Perform a function call.\n   *\n   * @param fn - The function name to call\n   * @param args - The arguments to pass to the function call\n   * @param options - Named parameters\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   * @param options.get - When set to `true`, the function will be called with\n   * read-only access mode.\n   * @param options.count - Count algorithm to use to count rows returned by the\n   * function. Only applicable for [set-returning\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  rpc<FnName extends string & keyof Schema['Functions'], Fn extends Schema['Functions'][FnName]>(\n    fn: FnName,\n    args: Fn['Args'] = {},\n    options: {\n      head?: boolean\n      get?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<\n    Schema,\n    Fn['Returns'] extends any[]\n      ? Fn['Returns'][number] extends Record<string, unknown>\n        ? Fn['Returns'][number]\n        : never\n      : never,\n    Fn['Returns'],\n    FnName,\n    null\n  > {\n    return this.rest.rpc(fn, args, options)\n  }\n\n  /**\n   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\n   *\n   * @param {string} name - The name of the Realtime channel.\n   * @param {Object} opts - The options to pass to the Realtime channel.\n   *\n   */\n  channel(name: string, opts: RealtimeChannelOptions = { config: {} }): RealtimeChannel {\n    return this.realtime.channel(name, opts)\n  }\n\n  /**\n   * Returns all Realtime channels.\n   */\n  getChannels(): RealtimeChannel[] {\n    return this.realtime.getChannels()\n  }\n\n  /**\n   * Unsubscribes and removes Realtime channel from Realtime client.\n   *\n   * @param {RealtimeChannel} channel - The name of the Realtime channel.\n   *\n   */\n  removeChannel(channel: RealtimeChannel): Promise<'ok' | 'timed out' | 'error'> {\n    return this.realtime.removeChannel(channel)\n  }\n\n  /**\n   * Unsubscribes and removes all Realtime channels from Realtime client.\n   */\n  removeAllChannels(): Promise<('ok' | 'timed out' | 'error')[]> {\n    return this.realtime.removeAllChannels()\n  }\n\n  private async _getAccessToken() {\n    if (this.accessToken) {\n      return await this.accessToken()\n    }\n\n    const { data } = await this.auth.getSession()\n\n    return data.session?.access_token ?? null\n  }\n\n  private _initSupabaseAuthClient(\n    {\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      storageKey,\n      flowType,\n      lock,\n      debug,\n    }: SupabaseAuthClientOptions,\n    headers?: Record<string, string>,\n    fetch?: Fetch\n  ) {\n    const authHeaders = {\n      Authorization: `Bearer ${this.supabaseKey}`,\n      apikey: `${this.supabaseKey}`,\n    }\n    return new SupabaseAuthClient({\n      url: this.authUrl,\n      headers: { ...authHeaders, ...headers },\n      storageKey: storageKey,\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      flowType,\n      lock,\n      debug,\n      fetch,\n      // auth checks if there is a custom authorizaiton header using this flag\n      // so it knows whether to return an error when getUser is called with no session\n      hasCustomAuthorizationHeader: 'Authorization' in this.headers,\n    })\n  }\n\n  private _initRealtimeClient(options: RealtimeClientOptions) {\n    return new RealtimeClient(this.realtimeUrl, {\n      ...options,\n      params: { ...{ apikey: this.supabaseKey }, ...options?.params },\n    })\n  }\n\n  private _listenForAuthEvents() {\n    let data = this.auth.onAuthStateChange((event, session) => {\n      this._handleTokenChanged(event, 'CLIENT', session?.access_token)\n    })\n    return data\n  }\n\n  private _handleTokenChanged(\n    event: AuthChangeEvent,\n    source: 'CLIENT' | 'STORAGE',\n    token?: string\n  ) {\n    if (\n      (event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') &&\n      this.changedAccessToken !== token\n    ) {\n      this.changedAccessToken = token\n    } else if (event === 'SIGNED_OUT') {\n      this.realtime.setAuth()\n      if (source == 'STORAGE') this.auth.signOut()\n      this.changedAccessToken = undefined\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}