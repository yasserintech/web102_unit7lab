{"ast":null,"code":"import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nimport * as Transformers from './lib/transformers';\nimport { httpEndpointURL } from './lib/transformers';\nexport var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\n\nexport var REALTIME_LISTEN_TYPES;\n\n(function (REALTIME_LISTEN_TYPES) {\n  REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n  REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n  REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n  REALTIME_LISTEN_TYPES[\"SYSTEM\"] = \"system\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\n\nexport var REALTIME_SUBSCRIBE_STATES;\n\n(function (REALTIME_SUBSCRIBE_STATES) {\n  REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n  REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n  REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n  REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\n\nexport const REALTIME_CHANNEL_STATES = CHANNEL_STATES;\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */\n\nexport default class RealtimeChannel {\n  constructor(\n  /** Topic name can be any string. */\n  topic) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      config: {}\n    };\n    let socket = arguments.length > 2 ? arguments[2] : undefined;\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = {};\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.subTopic = topic.replace(/^realtime:/i, '');\n    this.params.config = Object.assign({\n      broadcast: {\n        ack: false,\n        self: false\n      },\n      presence: {\n        key: ''\n      },\n      private: false\n    }, params.config);\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach(pushEvent => pushEvent.send());\n      this.pushBuffer = [];\n    });\n\n    this._onClose(() => {\n      this.rejoinTimer.reset();\n      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n\n      this.socket._remove(this);\n    });\n\n    this._onError(reason => {\n      if (this._isLeaving() || this._isClosed()) {\n        return;\n      }\n\n      this.socket.log('channel', `error ${this.topic}`, reason);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n\n    this.joinPush.receive('timeout', () => {\n      if (!this._isJoining()) {\n        return;\n      }\n\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n\n    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n      this._trigger(this._replyEventName(ref), payload);\n    });\n\n    this.presence = new RealtimePresence(this);\n    this.broadcastEndpointURL = httpEndpointURL(this.socket.endPoint) + '/api/broadcast';\n    this.private = this.params.config.private || false;\n  }\n  /** Subscribe registers your client with the server */\n\n\n  subscribe(callback) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.timeout;\n\n    var _a, _b;\n\n    if (!this.socket.isConnected()) {\n      this.socket.connect();\n    }\n\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n    } else {\n      const {\n        config: {\n          broadcast,\n          presence,\n          private: isPrivate\n        }\n      } = this.params;\n\n      this._onError(e => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));\n\n      this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));\n\n      const accessTokenPayload = {};\n      const config = {\n        broadcast,\n        presence,\n        postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map(r => r.filter)) !== null && _b !== void 0 ? _b : [],\n        private: isPrivate\n      };\n\n      if (this.socket.accessTokenValue) {\n        accessTokenPayload.access_token = this.socket.accessTokenValue;\n      }\n\n      this.updateJoinPayload(Object.assign({\n        config\n      }, accessTokenPayload));\n      this.joinedOnce = true;\n\n      this._rejoin(timeout);\n\n      this.joinPush.receive('ok', async _ref2 => {\n        let {\n          postgres_changes\n        } = _ref2;\n\n        var _a;\n\n        this.socket.setAuth();\n\n        if (postgres_changes === undefined) {\n          callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n          return;\n        } else {\n          const clientPostgresBindings = this.bindings.postgres_changes;\n          const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n          const newPostgresBindings = [];\n\n          for (let i = 0; i < bindingsLen; i++) {\n            const clientPostgresBinding = clientPostgresBindings[i];\n            const {\n              filter: {\n                event,\n                schema,\n                table,\n                filter\n              }\n            } = clientPostgresBinding;\n            const serverPostgresFilter = postgres_changes && postgres_changes[i];\n\n            if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {\n              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {\n                id: serverPostgresFilter.id\n              }));\n            } else {\n              this.unsubscribe();\n              callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error('mismatch between server and client bindings for postgres changes'));\n              return;\n            }\n          }\n\n          this.bindings.postgres_changes = newPostgresBindings;\n          callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n          return;\n        }\n      }).receive('error', error => {\n        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n        return;\n      }).receive('timeout', () => {\n        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);\n        return;\n      });\n    }\n\n    return this;\n  }\n\n  presenceState() {\n    return this.presence.state;\n  }\n\n  async track(payload) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return await this.send({\n      type: 'presence',\n      event: 'track',\n      payload\n    }, opts.timeout || this.timeout);\n  }\n\n  async untrack() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return await this.send({\n      type: 'presence',\n      event: 'untrack'\n    }, opts);\n  }\n\n  on(type, filter, callback) {\n    return this._on(type, filter, callback);\n  }\n  /**\n   * Sends a message into the channel.\n   *\n   * @param args Arguments to send to channel\n   * @param args.type The type of event to send\n   * @param args.event The name of the event being sent\n   * @param args.payload Payload to be sent\n   * @param opts Options to be used during the send process\n   */\n\n\n  async send(args) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _a, _b;\n\n    if (!this._canPush() && args.type === 'broadcast') {\n      const {\n        event,\n        payload: endpoint_payload\n      } = args;\n      const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : '';\n      const options = {\n        method: 'POST',\n        headers: {\n          Authorization: authorization,\n          apikey: this.socket.apiKey ? this.socket.apiKey : '',\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          messages: [{\n            topic: this.subTopic,\n            event,\n            payload: endpoint_payload,\n            private: this.private\n          }]\n        })\n      };\n\n      try {\n        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n        await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());\n        return response.ok ? 'ok' : 'error';\n      } catch (error) {\n        if (error.name === 'AbortError') {\n          return 'timed out';\n        } else {\n          return 'error';\n        }\n      }\n    } else {\n      return new Promise(resolve => {\n        var _a, _b, _c;\n\n        const push = this._push(args.type, args, opts.timeout || this.timeout);\n\n        if (args.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n          resolve('ok');\n        }\n\n        push.receive('ok', () => resolve('ok'));\n        push.receive('error', () => resolve('error'));\n        push.receive('timeout', () => resolve('timed out'));\n      });\n    }\n  }\n\n  updateJoinPayload(payload) {\n    this.joinPush.updatePayload(payload);\n  }\n  /**\n   * Leaves the channel.\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n\n\n  unsubscribe() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n    this.state = CHANNEL_STATES.leaving;\n\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`);\n\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef());\n    };\n\n    this.rejoinTimer.reset(); // Destroy joinPush to avoid connection timeouts during unscription phase\n\n    this.joinPush.destroy();\n    return new Promise(resolve => {\n      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive('ok', () => {\n        onClose();\n        resolve('ok');\n      }).receive('timeout', () => {\n        onClose();\n        resolve('timed out');\n      }).receive('error', () => {\n        resolve('error');\n      });\n      leavePush.send();\n\n      if (!this._canPush()) {\n        leavePush.trigger('ok', {});\n      }\n    });\n  }\n  /** @internal */\n\n\n  async _fetchWithTimeout(url, options, timeout) {\n    const controller = new AbortController();\n    const id = setTimeout(() => controller.abort(), timeout);\n    const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), {\n      signal: controller.signal\n    }));\n    clearTimeout(id);\n    return response;\n  }\n  /** @internal */\n\n\n  _push(event, payload) {\n    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;\n\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n    }\n\n    let pushEvent = new Push(this, event, payload, timeout);\n\n    if (this._canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n\n    return pushEvent;\n  }\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   *\n   * @internal\n   */\n\n\n  _onMessage(_event, payload, _ref) {\n    return payload;\n  }\n  /** @internal */\n\n\n  _isMember(topic) {\n    return this.topic === topic;\n  }\n  /** @internal */\n\n\n  _joinRef() {\n    return this.joinPush.ref;\n  }\n  /** @internal */\n\n\n  _trigger(type, payload, ref) {\n    var _a, _b;\n\n    const typeLower = type.toLocaleLowerCase();\n    const {\n      close,\n      error,\n      leave,\n      join\n    } = CHANNEL_EVENTS;\n    const events = [close, error, leave, join];\n\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n      return;\n    }\n\n    let handledPayload = this._onMessage(typeLower, payload, ref);\n\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n    }\n\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\n      (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter(bind => {\n        var _a, _b, _c;\n\n        return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n      }).map(bind => bind.callback(handledPayload, ref));\n    } else {\n      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter(bind => {\n        var _a, _b, _c, _d, _e, _f;\n\n        if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n          if ('id' in bind) {\n            const bindId = bind.id;\n            const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n            return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === '*' || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));\n          } else {\n            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n            return bindEvent === '*' || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\n          }\n        } else {\n          return bind.type.toLocaleLowerCase() === typeLower;\n        }\n      }).map(bind => {\n        if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n          const postgresChanges = handledPayload.data;\n          const {\n            schema,\n            table,\n            commit_timestamp,\n            type,\n            errors\n          } = postgresChanges;\n          const enrichedPayload = {\n            schema: schema,\n            table: table,\n            commit_timestamp: commit_timestamp,\n            eventType: type,\n            new: {},\n            old: {},\n            errors: errors\n          };\n          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n        }\n\n        bind.callback(handledPayload, ref);\n      });\n    }\n  }\n  /** @internal */\n\n\n  _isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  /** @internal */\n\n\n  _isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  /** @internal */\n\n\n  _isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  /** @internal */\n\n\n  _isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n  /** @internal */\n\n\n  _replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n  /** @internal */\n\n\n  _on(type, filter, callback) {\n    const typeLower = type.toLocaleLowerCase();\n    const binding = {\n      type: typeLower,\n      filter: filter,\n      callback: callback\n    };\n\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower].push(binding);\n    } else {\n      this.bindings[typeLower] = [binding];\n    }\n\n    return this;\n  }\n  /** @internal */\n\n\n  _off(type, filter) {\n    const typeLower = type.toLocaleLowerCase();\n    this.bindings[typeLower] = this.bindings[typeLower].filter(bind => {\n      var _a;\n\n      return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));\n    });\n    return this;\n  }\n  /** @internal */\n\n\n  static isEqual(obj1, obj2) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false;\n    }\n\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /** @internal */\n\n\n  _rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout();\n\n    if (this.socket.isConnected()) {\n      this._rejoin();\n    }\n  }\n  /**\n   * Registers a callback that will be executed when the channel closes.\n   *\n   * @internal\n   */\n\n\n  _onClose(callback) {\n    this._on(CHANNEL_EVENTS.close, {}, callback);\n  }\n  /**\n   * Registers a callback that will be executed when the channel encounteres an error.\n   *\n   * @internal\n   */\n\n\n  _onError(callback) {\n    this._on(CHANNEL_EVENTS.error, {}, reason => callback(reason));\n  }\n  /**\n   * Returns `true` if the socket is connected and the channel has been joined.\n   *\n   * @internal\n   */\n\n\n  _canPush() {\n    return this.socket.isConnected() && this._isJoined();\n  }\n  /** @internal */\n\n\n  _rejoin() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n    if (this._isLeaving()) {\n      return;\n    }\n\n    this.socket._leaveOpenTopic(this.topic);\n\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  /** @internal */\n\n\n  _getPayloadRecords(payload) {\n    const records = {\n      new: {},\n      old: {}\n    };\n\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(payload.columns, payload.record);\n    }\n\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n    }\n\n    return records;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["CHANNEL_EVENTS","CHANNEL_STATES","Push","Timer","RealtimePresence","Transformers","httpEndpointURL","REALTIME_POSTGRES_CHANGES_LISTEN_EVENT","REALTIME_LISTEN_TYPES","REALTIME_SUBSCRIBE_STATES","REALTIME_CHANNEL_STATES","RealtimeChannel","constructor","topic","params","config","socket","closed","subTopic","replace","Object","broadcast","ack","self","presence","key","private","timeout","joinPush","join","rejoinTimer","_rejoinUntilConnected","reconnectAfterMs","receive","state","joined","reset","pushBuffer","forEach","pushEvent","send","_onClose","log","_joinRef","_remove","_onError","reason","_isLeaving","_isClosed","errored","scheduleTimeout","_isJoining","_on","reply","payload","ref","_trigger","_replyEventName","broadcastEndpointURL","endPoint","subscribe","callback","isConnected","connect","joinedOnce","isPrivate","e","CHANNEL_ERROR","CLOSED","accessTokenPayload","postgres_changes","bindings","_a","map","r","filter","_b","accessTokenValue","access_token","updateJoinPayload","_rejoin","setAuth","undefined","SUBSCRIBED","clientPostgresBindings","bindingsLen","length","newPostgresBindings","i","clientPostgresBinding","event","schema","table","serverPostgresFilter","push","id","unsubscribe","Error","error","JSON","stringify","values","TIMED_OUT","presenceState","track","opts","type","untrack","on","args","_canPush","endpoint_payload","authorization","options","method","headers","Authorization","apikey","apiKey","body","messages","response","_fetchWithTimeout","cancel","ok","name","Promise","resolve","_push","_c","updatePayload","leaving","onClose","close","destroy","leavePush","leave","trigger","url","controller","AbortController","setTimeout","abort","fetch","signal","clearTimeout","startTimeout","_onMessage","_event","_ref","_isMember","typeLower","toLocaleLowerCase","events","indexOf","handledPayload","includes","bind","bindId","bindEvent","ids","data","_d","_e","_f","postgresChanges","commit_timestamp","errors","enrichedPayload","eventType","new","old","_getPayloadRecords","_isJoined","joining","binding","_off","isEqual","obj1","obj2","keys","k","_leaveOpenTopic","resend","records","convertChangeData","columns","record","old_record"],"sources":["/Users/grove/Desktop/repos/web102_unit7lab/client/node_modules/@supabase/realtime-js/src/RealtimeChannel.ts"],"sourcesContent":["import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants'\nimport Push from './lib/push'\nimport type RealtimeClient from './RealtimeClient'\nimport Timer from './lib/timer'\nimport RealtimePresence, {\n  REALTIME_PRESENCE_LISTEN_EVENTS,\n} from './RealtimePresence'\nimport type {\n  RealtimePresenceJoinPayload,\n  RealtimePresenceLeavePayload,\n  RealtimePresenceState,\n} from './RealtimePresence'\nimport * as Transformers from './lib/transformers'\nimport { httpEndpointURL } from './lib/transformers'\n\nexport type RealtimeChannelOptions = {\n  config: {\n    /**\n     * self option enables client to receive message it broadcast\n     * ack option instructs server to acknowledge that broadcast message was received\n     */\n    broadcast?: { self?: boolean; ack?: boolean }\n    /**\n     * key option is used to track presence payload across clients\n     */\n    presence?: { key?: string }\n    /**\n     * defines if the channel is private or not and if RLS policies will be used to check data\n     */\n    private?: boolean\n  }\n}\n\ntype RealtimePostgresChangesPayloadBase = {\n  schema: string\n  table: string\n  commit_timestamp: string\n  errors: string[]\n}\n\nexport type RealtimePostgresInsertPayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`\n    new: T\n    old: {}\n  }\n\nexport type RealtimePostgresUpdatePayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`\n    new: T\n    old: Partial<T>\n  }\n\nexport type RealtimePostgresDeletePayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`\n    new: {}\n    old: Partial<T>\n  }\n\nexport type RealtimePostgresChangesPayload<T extends { [key: string]: any }> =\n  | RealtimePostgresInsertPayload<T>\n  | RealtimePostgresUpdatePayload<T>\n  | RealtimePostgresDeletePayload<T>\n\nexport type RealtimePostgresChangesFilter<\n  T extends `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT}`\n> = {\n  /**\n   * The type of database change to listen to.\n   */\n  event: T\n  /**\n   * The database schema to listen to.\n   */\n  schema: string\n  /**\n   * The database table to listen to.\n   */\n  table?: string\n  /**\n   * Receive database changes when filter is matched.\n   */\n  filter?: string\n}\n\nexport type RealtimeChannelSendResponse = 'ok' | 'timed out' | 'error'\n\nexport enum REALTIME_POSTGRES_CHANGES_LISTEN_EVENT {\n  ALL = '*',\n  INSERT = 'INSERT',\n  UPDATE = 'UPDATE',\n  DELETE = 'DELETE',\n}\n\nexport enum REALTIME_LISTEN_TYPES {\n  BROADCAST = 'broadcast',\n  PRESENCE = 'presence',\n  POSTGRES_CHANGES = 'postgres_changes',\n  SYSTEM = 'system',\n}\n\nexport enum REALTIME_SUBSCRIBE_STATES {\n  SUBSCRIBED = 'SUBSCRIBED',\n  TIMED_OUT = 'TIMED_OUT',\n  CLOSED = 'CLOSED',\n  CHANNEL_ERROR = 'CHANNEL_ERROR',\n}\n\nexport const REALTIME_CHANNEL_STATES = CHANNEL_STATES\n\ninterface PostgresChangesFilters {\n  postgres_changes: {\n    id: string\n    event: string\n    schema?: string\n    table?: string\n    filter?: string\n  }[]\n}\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */\nexport default class RealtimeChannel {\n  bindings: {\n    [key: string]: {\n      type: string\n      filter: { [key: string]: any }\n      callback: Function\n      id?: string\n    }[]\n  } = {}\n  timeout: number\n  state = CHANNEL_STATES.closed\n  joinedOnce = false\n  joinPush: Push\n  rejoinTimer: Timer\n  pushBuffer: Push[] = []\n  presence: RealtimePresence\n  broadcastEndpointURL: string\n  subTopic: string\n  private: boolean\n\n  constructor(\n    /** Topic name can be any string. */\n    public topic: string,\n    public params: RealtimeChannelOptions = { config: {} },\n    public socket: RealtimeClient\n  ) {\n    this.subTopic = topic.replace(/^realtime:/i, '')\n    this.params.config = {\n      ...{\n        broadcast: { ack: false, self: false },\n        presence: { key: '' },\n        private: false,\n      },\n      ...params.config,\n    }\n    this.timeout = this.socket.timeout\n    this.joinPush = new Push(\n      this,\n      CHANNEL_EVENTS.join,\n      this.params,\n      this.timeout\n    )\n    this.rejoinTimer = new Timer(\n      () => this._rejoinUntilConnected(),\n      this.socket.reconnectAfterMs\n    )\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach((pushEvent: Push) => pushEvent.send())\n      this.pushBuffer = []\n    })\n    this._onClose(() => {\n      this.rejoinTimer.reset()\n      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket._remove(this)\n    })\n    this._onError((reason: string) => {\n      if (this._isLeaving() || this._isClosed()) {\n        return\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.joinPush.receive('timeout', () => {\n      if (!this._isJoining()) {\n        return\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this._on(CHANNEL_EVENTS.reply, {}, (payload: any, ref: string) => {\n      this._trigger(this._replyEventName(ref), payload)\n    })\n\n    this.presence = new RealtimePresence(this)\n\n    this.broadcastEndpointURL =\n      httpEndpointURL(this.socket.endPoint) + '/api/broadcast'\n    this.private = this.params.config.private || false\n  }\n\n  /** Subscribe registers your client with the server */\n  subscribe(\n    callback?: (status: REALTIME_SUBSCRIBE_STATES, err?: Error) => void,\n    timeout = this.timeout\n  ): RealtimeChannel {\n    if (!this.socket.isConnected()) {\n      this.socket.connect()\n    }\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`\n    } else {\n      const {\n        config: { broadcast, presence, private: isPrivate },\n      } = this.params\n\n      this._onError((e: Error) =>\n        callback?.(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e)\n      )\n      this._onClose(() => callback?.(REALTIME_SUBSCRIBE_STATES.CLOSED))\n\n      const accessTokenPayload: { access_token?: string } = {}\n      const config = {\n        broadcast,\n        presence,\n        postgres_changes:\n          this.bindings.postgres_changes?.map((r) => r.filter) ?? [],\n        private: isPrivate,\n      }\n\n      if (this.socket.accessTokenValue) {\n        accessTokenPayload.access_token = this.socket.accessTokenValue\n      }\n\n      this.updateJoinPayload({ ...{ config }, ...accessTokenPayload })\n\n      this.joinedOnce = true\n      this._rejoin(timeout)\n\n      this.joinPush\n        .receive('ok', async ({ postgres_changes }: PostgresChangesFilters) => {\n          this.socket.setAuth()\n          if (postgres_changes === undefined) {\n            callback?.(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED)\n            return\n          } else {\n            const clientPostgresBindings = this.bindings.postgres_changes\n            const bindingsLen = clientPostgresBindings?.length ?? 0\n            const newPostgresBindings = []\n\n            for (let i = 0; i < bindingsLen; i++) {\n              const clientPostgresBinding = clientPostgresBindings[i]\n              const {\n                filter: { event, schema, table, filter },\n              } = clientPostgresBinding\n              const serverPostgresFilter =\n                postgres_changes && postgres_changes[i]\n\n              if (\n                serverPostgresFilter &&\n                serverPostgresFilter.event === event &&\n                serverPostgresFilter.schema === schema &&\n                serverPostgresFilter.table === table &&\n                serverPostgresFilter.filter === filter\n              ) {\n                newPostgresBindings.push({\n                  ...clientPostgresBinding,\n                  id: serverPostgresFilter.id,\n                })\n              } else {\n                this.unsubscribe()\n                callback?.(\n                  REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR,\n                  new Error(\n                    'mismatch between server and client bindings for postgres changes'\n                  )\n                )\n                return\n              }\n            }\n\n            this.bindings.postgres_changes = newPostgresBindings\n\n            callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED)\n            return\n          }\n        })\n        .receive('error', (error: { [key: string]: any }) => {\n          callback?.(\n            REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR,\n            new Error(\n              JSON.stringify(Object.values(error).join(', ') || 'error')\n            )\n          )\n          return\n        })\n        .receive('timeout', () => {\n          callback?.(REALTIME_SUBSCRIBE_STATES.TIMED_OUT)\n          return\n        })\n    }\n    return this\n  }\n\n  presenceState<\n    T extends { [key: string]: any } = {}\n  >(): RealtimePresenceState<T> {\n    return this.presence.state as RealtimePresenceState<T>\n  }\n\n  async track(\n    payload: { [key: string]: any },\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    return await this.send(\n      {\n        type: 'presence',\n        event: 'track',\n        payload,\n      },\n      opts.timeout || this.timeout\n    )\n  }\n\n  async untrack(\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    return await this.send(\n      {\n        type: 'presence',\n        event: 'untrack',\n      },\n      opts\n    )\n  }\n\n  /**\n   * Creates an event handler that listens to changes.\n   */\n  on(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.SYNC}` },\n    callback: () => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.JOIN}` },\n    callback: (payload: RealtimePresenceJoinPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.LEAVE}` },\n    callback: (payload: RealtimePresenceLeavePayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.ALL}`>,\n    callback: (payload: RealtimePostgresChangesPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`>,\n    callback: (payload: RealtimePostgresInsertPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`>,\n    callback: (payload: RealtimePostgresUpdatePayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`>,\n    callback: (payload: RealtimePostgresDeletePayload<T>) => void\n  ): RealtimeChannel\n  /**\n   * The following is placed here to display on supabase.com/docs/reference/javascript/subscribe.\n   * @param type One of \"broadcast\", \"presence\", or \"postgres_changes\".\n   * @param filter Custom object specific to the Realtime feature detailing which payloads to receive.\n   * @param callback Function to be invoked when event handler is triggered.\n   */\n  on(\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\n    filter: { event: string },\n    callback: (payload: {\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\n      event: string\n      [key: string]: any\n    }) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\n    filter: { event: string },\n    callback: (payload: {\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\n      event: string\n      payload: T\n    }) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.SYSTEM}`,\n    filter: {},\n    callback: (payload: any) => void\n  ): RealtimeChannel\n  on(\n    type: `${REALTIME_LISTEN_TYPES}`,\n    filter: { event: string; [key: string]: string },\n    callback: (payload: any) => void\n  ): RealtimeChannel {\n    return this._on(type, filter, callback)\n  }\n  /**\n   * Sends a message into the channel.\n   *\n   * @param args Arguments to send to channel\n   * @param args.type The type of event to send\n   * @param args.event The name of the event being sent\n   * @param args.payload Payload to be sent\n   * @param opts Options to be used during the send process\n   */\n  async send(\n    args: {\n      type: 'broadcast' | 'presence' | 'postgres_changes'\n      event: string\n      payload?: any\n      [key: string]: any\n    },\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    if (!this._canPush() && args.type === 'broadcast') {\n      const { event, payload: endpoint_payload } = args\n      const authorization = this.socket.accessTokenValue\n        ? `Bearer ${this.socket.accessTokenValue}`\n        : ''\n      const options = {\n        method: 'POST',\n        headers: {\n          Authorization: authorization,\n          apikey: this.socket.apiKey ? this.socket.apiKey : '',\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          messages: [\n            {\n              topic: this.subTopic,\n              event,\n              payload: endpoint_payload,\n              private: this.private,\n            },\n          ],\n        }),\n      }\n\n      try {\n        const response = await this._fetchWithTimeout(\n          this.broadcastEndpointURL,\n          options,\n          opts.timeout ?? this.timeout\n        )\n\n        await response.body?.cancel()\n        return response.ok ? 'ok' : 'error'\n      } catch (error: any) {\n        if (error.name === 'AbortError') {\n          return 'timed out'\n        } else {\n          return 'error'\n        }\n      }\n    } else {\n      return new Promise((resolve) => {\n        const push = this._push(args.type, args, opts.timeout || this.timeout)\n\n        if (args.type === 'broadcast' && !this.params?.config?.broadcast?.ack) {\n          resolve('ok')\n        }\n\n        push.receive('ok', () => resolve('ok'))\n        push.receive('error', () => resolve('error'))\n        push.receive('timeout', () => resolve('timed out'))\n      })\n    }\n  }\n\n  updateJoinPayload(payload: { [key: string]: any }): void {\n    this.joinPush.updatePayload(payload)\n  }\n\n  /**\n   * Leaves the channel.\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n  unsubscribe(timeout = this.timeout): Promise<'ok' | 'timed out' | 'error'> {\n    this.state = CHANNEL_STATES.leaving\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`)\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef())\n    }\n\n    this.rejoinTimer.reset()\n    // Destroy joinPush to avoid connection timeouts during unscription phase\n    this.joinPush.destroy()\n\n    return new Promise((resolve) => {\n      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout)\n      leavePush\n        .receive('ok', () => {\n          onClose()\n          resolve('ok')\n        })\n        .receive('timeout', () => {\n          onClose()\n          resolve('timed out')\n        })\n        .receive('error', () => {\n          resolve('error')\n        })\n\n      leavePush.send()\n      if (!this._canPush()) {\n        leavePush.trigger('ok', {})\n      }\n    })\n  }\n\n  /** @internal */\n\n  async _fetchWithTimeout(\n    url: string,\n    options: { [key: string]: any },\n    timeout: number\n  ) {\n    const controller = new AbortController()\n    const id = setTimeout(() => controller.abort(), timeout)\n\n    const response = await this.socket.fetch(url, {\n      ...options,\n      signal: controller.signal,\n    })\n\n    clearTimeout(id)\n\n    return response\n  }\n\n  /** @internal */\n  _push(\n    event: string,\n    payload: { [key: string]: any },\n    timeout = this.timeout\n  ) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`\n    }\n    let pushEvent = new Push(this, event, payload, timeout)\n    if (this._canPush()) {\n      pushEvent.send()\n    } else {\n      pushEvent.startTimeout()\n      this.pushBuffer.push(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   *\n   * @internal\n   */\n  _onMessage(_event: string, payload: any, _ref?: string) {\n    return payload\n  }\n\n  /** @internal */\n  _isMember(topic: string): boolean {\n    return this.topic === topic\n  }\n\n  /** @internal */\n  _joinRef(): string {\n    return this.joinPush.ref\n  }\n\n  /** @internal */\n  _trigger(type: string, payload?: any, ref?: string) {\n    const typeLower = type.toLocaleLowerCase()\n    const { close, error, leave, join } = CHANNEL_EVENTS\n    const events: string[] = [close, error, leave, join]\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n      return\n    }\n    let handledPayload = this._onMessage(typeLower, payload, ref)\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified'\n    }\n\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\n      this.bindings.postgres_changes\n        ?.filter((bind) => {\n          return (\n            bind.filter?.event === '*' ||\n            bind.filter?.event?.toLocaleLowerCase() === typeLower\n          )\n        })\n        .map((bind) => bind.callback(handledPayload, ref))\n    } else {\n      this.bindings[typeLower]\n        ?.filter((bind) => {\n          if (\n            ['broadcast', 'presence', 'postgres_changes'].includes(typeLower)\n          ) {\n            if ('id' in bind) {\n              const bindId = bind.id\n              const bindEvent = bind.filter?.event\n              return (\n                bindId &&\n                payload.ids?.includes(bindId) &&\n                (bindEvent === '*' ||\n                  bindEvent?.toLocaleLowerCase() ===\n                    payload.data?.type.toLocaleLowerCase())\n              )\n            } else {\n              const bindEvent = bind?.filter?.event?.toLocaleLowerCase()\n              return (\n                bindEvent === '*' ||\n                bindEvent === payload?.event?.toLocaleLowerCase()\n              )\n            }\n          } else {\n            return bind.type.toLocaleLowerCase() === typeLower\n          }\n        })\n        .map((bind) => {\n          if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n            const postgresChanges = handledPayload.data\n            const { schema, table, commit_timestamp, type, errors } =\n              postgresChanges\n            const enrichedPayload = {\n              schema: schema,\n              table: table,\n              commit_timestamp: commit_timestamp,\n              eventType: type,\n              new: {},\n              old: {},\n              errors: errors,\n            }\n            handledPayload = {\n              ...enrichedPayload,\n              ...this._getPayloadRecords(postgresChanges),\n            }\n          }\n          bind.callback(handledPayload, ref)\n        })\n    }\n  }\n\n  /** @internal */\n  _isClosed(): boolean {\n    return this.state === CHANNEL_STATES.closed\n  }\n\n  /** @internal */\n  _isJoined(): boolean {\n    return this.state === CHANNEL_STATES.joined\n  }\n\n  /** @internal */\n  _isJoining(): boolean {\n    return this.state === CHANNEL_STATES.joining\n  }\n\n  /** @internal */\n  _isLeaving(): boolean {\n    return this.state === CHANNEL_STATES.leaving\n  }\n\n  /** @internal */\n  _replyEventName(ref: string): string {\n    return `chan_reply_${ref}`\n  }\n\n  /** @internal */\n  _on(type: string, filter: { [key: string]: any }, callback: Function) {\n    const typeLower = type.toLocaleLowerCase()\n\n    const binding = {\n      type: typeLower,\n      filter: filter,\n      callback: callback,\n    }\n\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower].push(binding)\n    } else {\n      this.bindings[typeLower] = [binding]\n    }\n\n    return this\n  }\n\n  /** @internal */\n  _off(type: string, filter: { [key: string]: any }) {\n    const typeLower = type.toLocaleLowerCase()\n\n    this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\n      return !(\n        bind.type?.toLocaleLowerCase() === typeLower &&\n        RealtimeChannel.isEqual(bind.filter, filter)\n      )\n    })\n    return this\n  }\n\n  /** @internal */\n  private static isEqual(\n    obj1: { [key: string]: string },\n    obj2: { [key: string]: string }\n  ) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false\n    }\n\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /** @internal */\n  private _rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout()\n    if (this.socket.isConnected()) {\n      this._rejoin()\n    }\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel closes.\n   *\n   * @internal\n   */\n  private _onClose(callback: Function) {\n    this._on(CHANNEL_EVENTS.close, {}, callback)\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel encounteres an error.\n   *\n   * @internal\n   */\n  private _onError(callback: Function) {\n    this._on(CHANNEL_EVENTS.error, {}, (reason: string) => callback(reason))\n  }\n\n  /**\n   * Returns `true` if the socket is connected and the channel has been joined.\n   *\n   * @internal\n   */\n  private _canPush(): boolean {\n    return this.socket.isConnected() && this._isJoined()\n  }\n\n  /** @internal */\n  private _rejoin(timeout = this.timeout): void {\n    if (this._isLeaving()) {\n      return\n    }\n    this.socket._leaveOpenTopic(this.topic)\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  /** @internal */\n  private _getPayloadRecords(payload: any) {\n    const records = {\n      new: {},\n      old: {},\n    }\n\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(\n        payload.columns,\n        payload.record\n      )\n    }\n\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(\n        payload.columns,\n        payload.old_record\n      )\n    }\n\n    return records\n  }\n}\n"]},"metadata":{},"sourceType":"module"}