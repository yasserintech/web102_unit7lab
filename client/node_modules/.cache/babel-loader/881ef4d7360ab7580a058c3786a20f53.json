{"ast":null,"code":"import { supportsLocalStorage } from './helpers';\n/**\n * @experimental\n */\n\nexport const internals = {\n  /**\n   * @experimental\n   */\n  debug: !!(globalThis && supportsLocalStorage() && globalThis.localStorage && globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true')\n};\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n */\n\nexport class LockAcquireTimeoutError extends Error {\n  constructor(message) {\n    super(message);\n    this.isAcquireTimeout = true;\n  }\n\n}\nexport class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {}\nexport class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {}\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\n\nexport async function navigatorLock(name, acquireTimeout, fn) {\n  if (internals.debug) {\n    console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout);\n  }\n\n  const abortController = new globalThis.AbortController();\n\n  if (acquireTimeout > 0) {\n    setTimeout(() => {\n      abortController.abort();\n\n      if (internals.debug) {\n        console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name);\n      }\n    }, acquireTimeout);\n  } // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n  // Wrapping navigator.locks.request() with a plain Promise is done as some\n  // libraries like zone.js patch the Promise object to track the execution\n  // context. However, it appears that most browsers use an internal promise\n  // implementation when using the navigator.locks.request() API causing them\n  // to lose context and emit confusing log messages or break certain features.\n  // This wrapping is believed to help zone.js track the execution context\n  // better.\n\n\n  return await Promise.resolve().then(() => globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {\n    mode: 'exclusive',\n    ifAvailable: true\n  } : {\n    mode: 'exclusive',\n    signal: abortController.signal\n  }, async lock => {\n    if (lock) {\n      if (internals.debug) {\n        console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name);\n      }\n\n      try {\n        return await fn();\n      } finally {\n        if (internals.debug) {\n          console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name);\n        }\n      }\n    } else {\n      if (acquireTimeout === 0) {\n        if (internals.debug) {\n          console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name);\n        }\n\n        throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);\n      } else {\n        if (internals.debug) {\n          try {\n            const result = await globalThis.navigator.locks.query();\n            console.log('@supabase/gotrue-js: Navigator LockManager state', JSON.stringify(result, null, '  '));\n          } catch (e) {\n            console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state', e);\n          }\n        } // Browser is not following the Navigator LockManager spec, it\n        // returned a null lock when we didn't use ifAvailable. So we can\n        // pretend the lock is acquired in the name of backward compatibility\n        // and user experience and just run the function.\n\n\n        console.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');\n        return await fn();\n      }\n    }\n  }));\n}\nconst PROCESS_LOCKS = {};\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\n\nexport async function processLock(name, acquireTimeout, fn) {\n  var _a;\n\n  const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\n  const currentOperation = Promise.race([previousOperation.catch(() => {\n    // ignore error of previous operation that we're waiting to finish\n    return null;\n  }), acquireTimeout >= 0 ? new Promise((_, reject) => {\n    setTimeout(() => {\n      reject(new ProcessLockAcquireTimeoutError(`Acquring process lock with name \"${name}\" timed out`));\n    }, acquireTimeout);\n  }) : null].filter(x => x)).catch(e => {\n    if (e && e.isAcquireTimeout) {\n      throw e;\n    }\n\n    return null;\n  }).then(async () => {\n    // previous operations finished and we didn't get a race on the acquire\n    // timeout, so the current operation can finally start\n    return await fn();\n  });\n  PROCESS_LOCKS[name] = currentOperation.catch(async e => {\n    if (e && e.isAcquireTimeout) {\n      // if the current operation timed out, it doesn't mean that the previous\n      // operation finished, so we need contnue waiting for it to finish\n      await previousOperation;\n      return null;\n    }\n\n    throw e;\n  }); // finally wait for the current operation to finish successfully, with an\n  // error or with an acquire timeout error\n\n  return await currentOperation;\n}","map":{"version":3,"mappings":"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","names":["supportsLocalStorage","internals","debug","globalThis","localStorage","getItem","LockAcquireTimeoutError","Error","constructor","message","NavigatorLockAcquireTimeoutError","ProcessLockAcquireTimeoutError","navigatorLock","name","acquireTimeout","fn","console","log","abortController","AbortController","setTimeout","abort","Promise","resolve","then","navigator","locks","request","mode","ifAvailable","signal","lock","result","query","JSON","stringify","e","warn","PROCESS_LOCKS","processLock","previousOperation","_a","currentOperation","race","catch","_","reject","filter","x","isAcquireTimeout"],"sources":["/Users/grove/Desktop/repos/web102_unit7lab/client/node_modules/@supabase/auth-js/src/lib/locks.ts"],"sourcesContent":["import { supportsLocalStorage } from './helpers'\n\n/**\n * @experimental\n */\nexport const internals = {\n  /**\n   * @experimental\n   */\n  debug: !!(\n    globalThis &&\n    supportsLocalStorage() &&\n    globalThis.localStorage &&\n    globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true'\n  ),\n}\n\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n */\nexport abstract class LockAcquireTimeoutError extends Error {\n  public readonly isAcquireTimeout = true\n\n  constructor(message: string) {\n    super(message)\n  }\n}\n\nexport class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {}\nexport class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {}\n\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nexport async function navigatorLock<R>(\n  name: string,\n  acquireTimeout: number,\n  fn: () => Promise<R>\n): Promise<R> {\n  if (internals.debug) {\n    console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout)\n  }\n\n  const abortController = new globalThis.AbortController()\n\n  if (acquireTimeout > 0) {\n    setTimeout(() => {\n      abortController.abort()\n      if (internals.debug) {\n        console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name)\n      }\n    }, acquireTimeout)\n  }\n\n  // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n\n  // Wrapping navigator.locks.request() with a plain Promise is done as some\n  // libraries like zone.js patch the Promise object to track the execution\n  // context. However, it appears that most browsers use an internal promise\n  // implementation when using the navigator.locks.request() API causing them\n  // to lose context and emit confusing log messages or break certain features.\n  // This wrapping is believed to help zone.js track the execution context\n  // better.\n  return await Promise.resolve().then(() =>\n    globalThis.navigator.locks.request(\n      name,\n      acquireTimeout === 0\n        ? {\n            mode: 'exclusive',\n            ifAvailable: true,\n          }\n        : {\n            mode: 'exclusive',\n            signal: abortController.signal,\n          },\n      async (lock) => {\n        if (lock) {\n          if (internals.debug) {\n            console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name)\n          }\n\n          try {\n            return await fn()\n          } finally {\n            if (internals.debug) {\n              console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name)\n            }\n          }\n        } else {\n          if (acquireTimeout === 0) {\n            if (internals.debug) {\n              console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name)\n            }\n\n            throw new NavigatorLockAcquireTimeoutError(\n              `Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`\n            )\n          } else {\n            if (internals.debug) {\n              try {\n                const result = await globalThis.navigator.locks.query()\n\n                console.log(\n                  '@supabase/gotrue-js: Navigator LockManager state',\n                  JSON.stringify(result, null, '  ')\n                )\n              } catch (e: any) {\n                console.warn(\n                  '@supabase/gotrue-js: Error when querying Navigator LockManager state',\n                  e\n                )\n              }\n            }\n\n            // Browser is not following the Navigator LockManager spec, it\n            // returned a null lock when we didn't use ifAvailable. So we can\n            // pretend the lock is acquired in the name of backward compatibility\n            // and user experience and just run the function.\n            console.warn(\n              '@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request'\n            )\n\n            return await fn()\n          }\n        }\n      }\n    )\n  )\n}\n\nconst PROCESS_LOCKS: { [name: string]: Promise<any> } = {}\n\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nexport async function processLock<R>(\n  name: string,\n  acquireTimeout: number,\n  fn: () => Promise<R>\n): Promise<R> {\n  const previousOperation = PROCESS_LOCKS[name] ?? Promise.resolve()\n\n  const currentOperation = Promise.race(\n    [\n      previousOperation.catch(() => {\n        // ignore error of previous operation that we're waiting to finish\n        return null\n      }),\n      acquireTimeout >= 0\n        ? new Promise((_, reject) => {\n            setTimeout(() => {\n              reject(\n                new ProcessLockAcquireTimeoutError(\n                  `Acquring process lock with name \"${name}\" timed out`\n                )\n              )\n            }, acquireTimeout)\n          })\n        : null,\n    ].filter((x) => x)\n  )\n    .catch((e: any) => {\n      if (e && e.isAcquireTimeout) {\n        throw e\n      }\n\n      return null\n    })\n    .then(async () => {\n      // previous operations finished and we didn't get a race on the acquire\n      // timeout, so the current operation can finally start\n      return await fn()\n    })\n\n  PROCESS_LOCKS[name] = currentOperation.catch(async (e: any) => {\n    if (e && e.isAcquireTimeout) {\n      // if the current operation timed out, it doesn't mean that the previous\n      // operation finished, so we need contnue waiting for it to finish\n      await previousOperation\n\n      return null\n    }\n\n    throw e\n  })\n\n  // finally wait for the current operation to finish successfully, with an\n  // error or with an acquire timeout error\n  return await currentOperation\n}\n"]},"metadata":{},"sourceType":"module"}